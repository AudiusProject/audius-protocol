// @ts-nocheck
/* tslint:disable */
/* eslint-disable */
/**
 * API
 * Audius V1 API
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    ConnectedWalletsResponse,
    ConnectedWalletsResponseFromJSON,
    ConnectedWalletsResponseToJSON,
    FavoritesResponse,
    FavoritesResponseFromJSON,
    FavoritesResponseToJSON,
    GetSupporters,
    GetSupportersFromJSON,
    GetSupportersToJSON,
    GetSupporting,
    GetSupportingFromJSON,
    GetSupportingToJSON,
    Reposts,
    RepostsFromJSON,
    RepostsToJSON,
    TagsResponse,
    TagsResponseFromJSON,
    TagsResponseToJSON,
    TracksResponse,
    TracksResponseFromJSON,
    TracksResponseToJSON,
    UserAssociatedWalletResponse,
    UserAssociatedWalletResponseFromJSON,
    UserAssociatedWalletResponseToJSON,
    UserResponse,
    UserResponseFromJSON,
    UserResponseToJSON,
    UserSearch,
    UserSearchFromJSON,
    UserSearchToJSON,
    VerifyToken,
    VerifyTokenFromJSON,
    VerifyTokenToJSON,
} from '../models';

export interface GetConnectedWalletsRequest {
    /**
     * A User ID
     */
    id: string;
}

export interface GetFavoritesRequest {
    /**
     * A User ID
     */
    id: string;
}

export interface GetRepostsRequest {
    /**
     * A User ID
     */
    id: string;
    /**
     * The number of items to skip. Useful for pagination (page number * limit)
     */
    offset?: number;
    /**
     * The number of items to fetch
     */
    limit?: number;
    /**
     * The user ID of the user making the request
     */
    userId?: string;
}

export interface GetSupportersRequest {
    /**
     * A User ID
     */
    id: string;
    /**
     * The number of items to skip. Useful for pagination (page number * limit)
     */
    offset?: number;
    /**
     * The number of items to fetch
     */
    limit?: number;
}

export interface GetSupportingsRequest {
    /**
     * A User ID
     */
    id: string;
    /**
     * The number of items to skip. Useful for pagination (page number * limit)
     */
    offset?: number;
    /**
     * The number of items to fetch
     */
    limit?: number;
}

export interface GetTopTrackTagsRequest {
    /**
     * A User ID
     */
    id: string;
    /**
     * The number of items to fetch
     */
    limit?: number;
    /**
     * The user ID of the user making the request
     */
    userId?: string;
}

export interface GetTracksByUserRequest {
    /**
     * A User ID
     */
    id: string;
    /**
     * The number of items to skip. Useful for pagination (page number * limit)
     */
    offset?: number;
    /**
     * The number of items to fetch
     */
    limit?: number;
    /**
     * The user ID of the user making the request
     */
    userId?: string;
    /**
     * Field to sort by
     */
    sort?: GetTracksByUserSortEnum;
}

export interface GetUserRequest {
    /**
     * A User ID
     */
    id: string;
}

export interface GetUserIDFromWalletRequest {
    /**
     * Wallet address
     */
    associatedWallet: string;
}

export interface SearchUsersRequest {
    /**
     * The search query
     */
    query: string;
}

export interface VerifyIDTokenRequest {
    /**
     * JWT to verify
     */
    token: string;
}

/**
 * 
 */
export class UsersApi extends runtime.BaseAPI {

    /**
     * Get the User\'s ERC and SPL connected wallets
     */
    async getConnectedWallets(requestParameters: GetConnectedWalletsRequest): Promise<NonNullable<ConnectedWalletsResponse["data"]>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getConnectedWallets.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        return this.request({
            path: `/users/{id}/connected_wallets`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }) as Promise<NonNullable<ConnectedWalletsResponse["data"]>>;
    }

    /**
     * Gets a user\'s favorite tracks
     */
    async getFavorites(requestParameters: GetFavoritesRequest): Promise<NonNullable<FavoritesResponse["data"]>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getFavorites.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        return this.request({
            path: `/users/{id}/favorites`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }) as Promise<NonNullable<FavoritesResponse["data"]>>;
    }

    /**
     * Gets the given user\'s reposts
     */
    async getReposts(requestParameters: GetRepostsRequest): Promise<NonNullable<Reposts["data"]>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getReposts.');
        }

        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        return this.request({
            path: `/users/{id}/reposts`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }) as Promise<NonNullable<Reposts["data"]>>;
    }

    /**
     * Gets the supporters of the given user
     */
    async getSupporters(requestParameters: GetSupportersRequest): Promise<NonNullable<GetSupporters["data"]>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getSupporters.');
        }

        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        return this.request({
            path: `/users/{id}/supporters`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }) as Promise<NonNullable<GetSupporters["data"]>>;
    }

    /**
     * Gets the users that the given user supports
     */
    async getSupportings(requestParameters: GetSupportingsRequest): Promise<NonNullable<GetSupporting["data"]>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getSupportings.');
        }

        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        return this.request({
            path: `/users/{id}/supporting`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }) as Promise<NonNullable<GetSupporting["data"]>>;
    }

    /**
     * Gets the most used track tags by a user.
     * Fetch most used tags in a user\'s tracks
     */
    async getTopTrackTags(requestParameters: GetTopTrackTagsRequest): Promise<NonNullable<TagsResponse["data"]>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getTopTrackTags.');
        }

        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        return this.request({
            path: `/users/{id}/tags`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }) as Promise<NonNullable<TagsResponse["data"]>>;
    }

    /**
     * Gets the tracks created by a user using their user ID
     */
    async getTracksByUser(requestParameters: GetTracksByUserRequest): Promise<NonNullable<TracksResponse["data"]>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getTracksByUser.');
        }

        const queryParameters: any = {};

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters['sort'] = requestParameters.sort;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        return this.request({
            path: `/users/{id}/tracks`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }) as Promise<NonNullable<TracksResponse["data"]>>;
    }

    /**
     * Gets a single user by their user ID
     */
    async getUser(requestParameters: GetUserRequest): Promise<NonNullable<UserResponse["data"]>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getUser.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        return this.request({
            path: `/users/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }) as Promise<NonNullable<UserResponse["data"]>>;
    }

    /**
     * Gets a User ID from an associated wallet address
     */
    async getUserIDFromWallet(requestParameters: GetUserIDFromWalletRequest): Promise<NonNullable<UserAssociatedWalletResponse["data"]>> {
        if (requestParameters.associatedWallet === null || requestParameters.associatedWallet === undefined) {
            throw new runtime.RequiredError('associatedWallet','Required parameter requestParameters.associatedWallet was null or undefined when calling getUserIDFromWallet.');
        }

        const queryParameters: any = {};

        if (requestParameters.associatedWallet !== undefined) {
            queryParameters['associated_wallet'] = requestParameters.associatedWallet;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        return this.request({
            path: `/users/id`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }) as Promise<NonNullable<UserAssociatedWalletResponse["data"]>>;
    }

    /**
     * Search for users that match the given query
     */
    async searchUsers(requestParameters: SearchUsersRequest): Promise<NonNullable<UserSearch["data"]>> {
        if (requestParameters.query === null || requestParameters.query === undefined) {
            throw new runtime.RequiredError('query','Required parameter requestParameters.query was null or undefined when calling searchUsers.');
        }

        const queryParameters: any = {};

        if (requestParameters.query !== undefined) {
            queryParameters['query'] = requestParameters.query;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        return this.request({
            path: `/users/search`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }) as Promise<NonNullable<UserSearch["data"]>>;
    }

    /**
     * Verify if the given jwt ID token was signed by the subject (user) in the payload
     */
    async verifyIDToken(requestParameters: VerifyIDTokenRequest): Promise<NonNullable<VerifyToken["data"]>> {
        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling verifyIDToken.');
        }

        const queryParameters: any = {};

        if (requestParameters.token !== undefined) {
            queryParameters['token'] = requestParameters.token;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        return this.request({
            path: `/users/verify_token`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }) as Promise<NonNullable<VerifyToken["data"]>>;
    }

}

/**
    * @export
    * @enum {string}
    */
export enum GetTracksByUserSortEnum {
    Date = 'date',
    Plays = 'plays'
}
