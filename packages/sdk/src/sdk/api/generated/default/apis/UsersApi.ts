/* tslint:disable */
// @ts-nocheck
/* eslint-disable */
/**
 * API
 * Audius V1 API
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AlbumsResponse,
  AuthorizedApps,
  ConnectedWalletsResponse,
  DeveloperApps,
  EmailKeyResponse,
  FavoritesResponse,
  FollowersResponse,
  FollowingResponse,
  GetChallenges,
  GetSupportedUsers,
  GetSupporters,
  MutualFollowersResponse,
  PlaylistsResponse,
  PurchasersResponse,
  RelatedArtistResponse,
  RemixersResponse,
  Reposts,
  SalesAggregateResponse,
  SalesJsonResponse,
  SubscribersResponse,
  TagsResponse,
  TracksResponse,
  UserAssociatedWalletResponse,
  UserResponse,
  UserSearch,
  UserTrackListenCountsResponse,
  UserTracksRemixedResponse,
  UsersResponse,
  VerifyToken,
} from '../models';
import {
    AlbumsResponseFromJSON,
    AlbumsResponseToJSON,
    AuthorizedAppsFromJSON,
    AuthorizedAppsToJSON,
    ConnectedWalletsResponseFromJSON,
    ConnectedWalletsResponseToJSON,
    DeveloperAppsFromJSON,
    DeveloperAppsToJSON,
    EmailKeyResponseFromJSON,
    EmailKeyResponseToJSON,
    FavoritesResponseFromJSON,
    FavoritesResponseToJSON,
    FollowersResponseFromJSON,
    FollowersResponseToJSON,
    FollowingResponseFromJSON,
    FollowingResponseToJSON,
    GetChallengesFromJSON,
    GetChallengesToJSON,
    GetSupportedUsersFromJSON,
    GetSupportedUsersToJSON,
    GetSupportersFromJSON,
    GetSupportersToJSON,
    MutualFollowersResponseFromJSON,
    MutualFollowersResponseToJSON,
    PlaylistsResponseFromJSON,
    PlaylistsResponseToJSON,
    PurchasersResponseFromJSON,
    PurchasersResponseToJSON,
    RelatedArtistResponseFromJSON,
    RelatedArtistResponseToJSON,
    RemixersResponseFromJSON,
    RemixersResponseToJSON,
    RepostsFromJSON,
    RepostsToJSON,
    SalesAggregateResponseFromJSON,
    SalesAggregateResponseToJSON,
    SalesJsonResponseFromJSON,
    SalesJsonResponseToJSON,
    SubscribersResponseFromJSON,
    SubscribersResponseToJSON,
    TagsResponseFromJSON,
    TagsResponseToJSON,
    TracksResponseFromJSON,
    TracksResponseToJSON,
    UserAssociatedWalletResponseFromJSON,
    UserAssociatedWalletResponseToJSON,
    UserResponseFromJSON,
    UserResponseToJSON,
    UserSearchFromJSON,
    UserSearchToJSON,
    UserTrackListenCountsResponseFromJSON,
    UserTrackListenCountsResponseToJSON,
    UserTracksRemixedResponseFromJSON,
    UserTracksRemixedResponseToJSON,
    UsersResponseFromJSON,
    UsersResponseToJSON,
    VerifyTokenFromJSON,
    VerifyTokenToJSON,
} from '../models';

export interface DownloadPurchasesAsCSVRequest {
    id: string;
    userId?: string;
    encodedDataMessage?: string;
    encodedDataSignature?: string;
}

export interface DownloadSalesAsCSVRequest {
    id: string;
    userId?: string;
    encodedDataMessage?: string;
    encodedDataSignature?: string;
}

export interface DownloadSalesAsJSONRequest {
    id: string;
    userId?: string;
    encodedDataMessage?: string;
    encodedDataSignature?: string;
}

export interface DownloadUSDCWithdrawalsAsCSVRequest {
    id: string;
    userId?: string;
    encodedDataMessage?: string;
    encodedDataSignature?: string;
}

export interface GetAIAttributedTracksByUserHandleRequest {
    handle: string;
    offset?: number;
    limit?: number;
    userId?: string;
    sort?: GetAIAttributedTracksByUserHandleSortEnum;
    query?: string;
    sortMethod?: GetAIAttributedTracksByUserHandleSortMethodEnum;
    sortDirection?: GetAIAttributedTracksByUserHandleSortDirectionEnum;
    filterTracks?: GetAIAttributedTracksByUserHandleFilterTracksEnum;
    encodedDataMessage?: string;
    encodedDataSignature?: string;
}

export interface GetAlbumsByUserRequest {
    id: string;
    offset?: number;
    limit?: number;
    userId?: string;
    encodedDataMessage?: string;
    encodedDataSignature?: string;
}

export interface GetAuthorizedAppsRequest {
    id: string;
}

export interface GetBulkUsersRequest {
    userId?: string;
    id?: Array<string>;
}

export interface GetConnectedWalletsRequest {
    id: string;
}

export interface GetDeveloperAppsRequest {
    id: string;
}

export interface GetFavoritesRequest {
    id: string;
}

export interface GetFollowersRequest {
    id: string;
    offset?: number;
    limit?: number;
    userId?: string;
}

export interface GetFollowingRequest {
    id: string;
    offset?: number;
    limit?: number;
    userId?: string;
}

export interface GetMutedUsersRequest {
    id: string;
    encodedDataMessage?: string;
    encodedDataSignature?: string;
}

export interface GetMutualFollowersRequest {
    id: string;
    offset?: number;
    limit?: number;
    userId?: string;
}

export interface GetPlaylistsByUserRequest {
    id: string;
    offset?: number;
    limit?: number;
    userId?: string;
    encodedDataMessage?: string;
    encodedDataSignature?: string;
}

export interface GetPurchasersRequest {
    id: string;
    offset?: number;
    limit?: number;
    userId?: string;
    contentType?: string;
    contentId?: string;
}

export interface GetRelatedUsersRequest {
    id: string;
    offset?: number;
    limit?: number;
    userId?: string;
}

export interface GetRemixersRequest {
    id: string;
    offset?: number;
    limit?: number;
    userId?: string;
    trackId?: string;
}

export interface GetRepostsRequest {
    id: string;
    offset?: number;
    limit?: number;
    userId?: string;
}

export interface GetSalesAggregateRequest {
    id: string;
    offset?: number;
    limit?: number;
    userId?: string;
    encodedDataMessage?: string;
    encodedDataSignature?: string;
}

export interface GetSubscribersRequest {
    id: string;
    offset?: number;
    limit?: number;
    userId?: string;
}

export interface GetSupportedUsersRequest {
    id: string;
    offset?: number;
    limit?: number;
}

export interface GetSupportersRequest {
    id: string;
    offset?: number;
    limit?: number;
}

export interface GetTopTrackTagsRequest {
    id: string;
    limit?: number;
    userId?: string;
}

export interface GetTracksByUserRequest {
    id: string;
    offset?: number;
    limit?: number;
    userId?: string;
    sort?: GetTracksByUserSortEnum;
    query?: string;
    sortMethod?: GetTracksByUserSortMethodEnum;
    sortDirection?: GetTracksByUserSortDirectionEnum;
    filterTracks?: GetTracksByUserFilterTracksEnum;
    encodedDataMessage?: string;
    encodedDataSignature?: string;
}

export interface GetUserRequest {
    id: string;
}

export interface GetUserByHandleRequest {
    handle: string;
    userId?: string;
}

export interface GetUserChallengesRequest {
    id: string;
    showHistorical?: boolean;
}

export interface GetUserEmailKeyRequest {
    id: string;
}

export interface GetUserIDFromWalletRequest {
    associatedWallet: string;
}

export interface GetUserMonthlyTrackListensRequest {
    id: string;
    startTime: string;
    endTime: string;
}

export interface GetUserTracksRemixedRequest {
    id: string;
    offset?: number;
    limit?: number;
    userId?: string;
}

export interface SearchUsersRequest {
    query?: string;
    genre?: Array<string>;
    sortMethod?: SearchUsersSortMethodEnum;
    isVerified?: string;
}

export interface VerifyIDTokenRequest {
    token: string;
}

/**
 * 
 */
export class UsersApi extends runtime.BaseAPI {

    /**
     * @hidden
     * Downloads the purchases the user has made as a CSV file
     */
    async downloadPurchasesAsCSVRaw(params: DownloadPurchasesAsCSVRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling downloadPurchasesAsCSV.');
        }

        const queryParameters: any = {};

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
            headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
        }

        if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
            headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
        }

        const response = await this.request({
            path: `/users/{id}/purchases/download`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Downloads the purchases the user has made as a CSV file
     */
    async downloadPurchasesAsCSV(params: DownloadPurchasesAsCSVRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.downloadPurchasesAsCSVRaw(params, initOverrides);
    }

    /**
     * @hidden
     * Downloads the sales the user has made as a CSV file
     */
    async downloadSalesAsCSVRaw(params: DownloadSalesAsCSVRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling downloadSalesAsCSV.');
        }

        const queryParameters: any = {};

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
            headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
        }

        if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
            headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
        }

        const response = await this.request({
            path: `/users/{id}/sales/download`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Downloads the sales the user has made as a CSV file
     */
    async downloadSalesAsCSV(params: DownloadSalesAsCSVRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.downloadSalesAsCSVRaw(params, initOverrides);
    }

    /**
     * @hidden
     * Gets the sales data for the user in JSON format
     */
    async downloadSalesAsJSONRaw(params: DownloadSalesAsJSONRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SalesJsonResponse>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling downloadSalesAsJSON.');
        }

        const queryParameters: any = {};

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
            headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
        }

        if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
            headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
        }

        const response = await this.request({
            path: `/users/{id}/sales/download/json`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SalesJsonResponseFromJSON(jsonValue));
    }

    /**
     * Gets the sales data for the user in JSON format
     */
    async downloadSalesAsJSON(params: DownloadSalesAsJSONRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SalesJsonResponse> {
        const response = await this.downloadSalesAsJSONRaw(params, initOverrides);
        return await response.value();
    }

    /**
     * @hidden
     * Downloads the USDC withdrawals the user has made as a CSV file
     */
    async downloadUSDCWithdrawalsAsCSVRaw(params: DownloadUSDCWithdrawalsAsCSVRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling downloadUSDCWithdrawalsAsCSV.');
        }

        const queryParameters: any = {};

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
            headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
        }

        if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
            headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
        }

        const response = await this.request({
            path: `/users/{id}/withdrawals/download`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Downloads the USDC withdrawals the user has made as a CSV file
     */
    async downloadUSDCWithdrawalsAsCSV(params: DownloadUSDCWithdrawalsAsCSVRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.downloadUSDCWithdrawalsAsCSVRaw(params, initOverrides);
    }

    /**
     * @hidden
     * Gets the AI generated tracks attributed to a user using the user\'s handle
     */
    async getAIAttributedTracksByUserHandleRaw(params: GetAIAttributedTracksByUserHandleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TracksResponse>> {
        if (params.handle === null || params.handle === undefined) {
            throw new runtime.RequiredError('handle','Required parameter params.handle was null or undefined when calling getAIAttributedTracksByUserHandle.');
        }

        const queryParameters: any = {};

        if (params.offset !== undefined) {
            queryParameters['offset'] = params.offset;
        }

        if (params.limit !== undefined) {
            queryParameters['limit'] = params.limit;
        }

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        if (params.sort !== undefined) {
            queryParameters['sort'] = params.sort;
        }

        if (params.query !== undefined) {
            queryParameters['query'] = params.query;
        }

        if (params.sortMethod !== undefined) {
            queryParameters['sort_method'] = params.sortMethod;
        }

        if (params.sortDirection !== undefined) {
            queryParameters['sort_direction'] = params.sortDirection;
        }

        if (params.filterTracks !== undefined) {
            queryParameters['filter_tracks'] = params.filterTracks;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
            headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
        }

        if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
            headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
        }

        const response = await this.request({
            path: `/users/handle/{handle}/tracks/ai_attributed`.replace(`{${"handle"}}`, encodeURIComponent(String(params.handle))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TracksResponseFromJSON(jsonValue));
    }

    /**
     * Gets the AI generated tracks attributed to a user using the user\'s handle
     */
    async getAIAttributedTracksByUserHandle(params: GetAIAttributedTracksByUserHandleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TracksResponse> {
        const response = await this.getAIAttributedTracksByUserHandleRaw(params, initOverrides);
        return await response.value();
    }

    /**
     * @hidden
     * Gets the albums created by a user using their user ID
     */
    async getAlbumsByUserRaw(params: GetAlbumsByUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AlbumsResponse>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getAlbumsByUser.');
        }

        const queryParameters: any = {};

        if (params.offset !== undefined) {
            queryParameters['offset'] = params.offset;
        }

        if (params.limit !== undefined) {
            queryParameters['limit'] = params.limit;
        }

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
            headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
        }

        if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
            headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
        }

        const response = await this.request({
            path: `/users/{id}/albums`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AlbumsResponseFromJSON(jsonValue));
    }

    /**
     * Gets the albums created by a user using their user ID
     */
    async getAlbumsByUser(params: GetAlbumsByUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AlbumsResponse> {
        const response = await this.getAlbumsByUserRaw(params, initOverrides);
        return await response.value();
    }

    /**
     * @hidden
     * Get the apps that user has authorized to write to their account
     */
    async getAuthorizedAppsRaw(params: GetAuthorizedAppsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthorizedApps>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getAuthorizedApps.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/authorized_apps`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AuthorizedAppsFromJSON(jsonValue));
    }

    /**
     * Get the apps that user has authorized to write to their account
     */
    async getAuthorizedApps(params: GetAuthorizedAppsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthorizedApps> {
        const response = await this.getAuthorizedAppsRaw(params, initOverrides);
        return await response.value();
    }

    /**
     * @hidden
     * Gets a list of users by ID
     */
    async getBulkUsersRaw(params: GetBulkUsersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UsersResponse>> {
        const queryParameters: any = {};

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        if (params.id) {
            queryParameters['id'] = params.id;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UsersResponseFromJSON(jsonValue));
    }

    /**
     * Gets a list of users by ID
     */
    async getBulkUsers(params: GetBulkUsersRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UsersResponse> {
        const response = await this.getBulkUsersRaw(params, initOverrides);
        return await response.value();
    }

    /**
     * @hidden
     * Get the User\'s ERC and SPL connected wallets
     */
    async getConnectedWalletsRaw(params: GetConnectedWalletsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConnectedWalletsResponse>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getConnectedWallets.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/connected_wallets`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConnectedWalletsResponseFromJSON(jsonValue));
    }

    /**
     * Get the User\'s ERC and SPL connected wallets
     */
    async getConnectedWallets(params: GetConnectedWalletsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConnectedWalletsResponse> {
        const response = await this.getConnectedWalletsRaw(params, initOverrides);
        return await response.value();
    }

    /**
     * @hidden
     * Gets the developer apps that the user owns
     */
    async getDeveloperAppsRaw(params: GetDeveloperAppsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeveloperApps>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getDeveloperApps.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/developer_apps`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DeveloperAppsFromJSON(jsonValue));
    }

    /**
     * Gets the developer apps that the user owns
     */
    async getDeveloperApps(params: GetDeveloperAppsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeveloperApps> {
        const response = await this.getDeveloperAppsRaw(params, initOverrides);
        return await response.value();
    }

    /**
     * @hidden
     * Gets a user\'s favorite tracks
     */
    async getFavoritesRaw(params: GetFavoritesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FavoritesResponse>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getFavorites.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/favorites`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FavoritesResponseFromJSON(jsonValue));
    }

    /**
     * Gets a user\'s favorite tracks
     */
    async getFavorites(params: GetFavoritesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FavoritesResponse> {
        const response = await this.getFavoritesRaw(params, initOverrides);
        return await response.value();
    }

    /**
     * @hidden
     * All users that follow the provided user
     */
    async getFollowersRaw(params: GetFollowersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FollowersResponse>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getFollowers.');
        }

        const queryParameters: any = {};

        if (params.offset !== undefined) {
            queryParameters['offset'] = params.offset;
        }

        if (params.limit !== undefined) {
            queryParameters['limit'] = params.limit;
        }

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/followers`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FollowersResponseFromJSON(jsonValue));
    }

    /**
     * All users that follow the provided user
     */
    async getFollowers(params: GetFollowersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FollowersResponse> {
        const response = await this.getFollowersRaw(params, initOverrides);
        return await response.value();
    }

    /**
     * @hidden
     * All users that the provided user follows
     */
    async getFollowingRaw(params: GetFollowingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FollowingResponse>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getFollowing.');
        }

        const queryParameters: any = {};

        if (params.offset !== undefined) {
            queryParameters['offset'] = params.offset;
        }

        if (params.limit !== undefined) {
            queryParameters['limit'] = params.limit;
        }

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/following`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FollowingResponseFromJSON(jsonValue));
    }

    /**
     * All users that the provided user follows
     */
    async getFollowing(params: GetFollowingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FollowingResponse> {
        const response = await this.getFollowingRaw(params, initOverrides);
        return await response.value();
    }

    /**
     * @hidden
     * Gets users muted by the given user
     */
    async getMutedUsersRaw(params: GetMutedUsersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UsersResponse>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getMutedUsers.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
            headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
        }

        if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
            headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
        }

        const response = await this.request({
            path: `/users/{id}/muted`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UsersResponseFromJSON(jsonValue));
    }

    /**
     * Gets users muted by the given user
     */
    async getMutedUsers(params: GetMutedUsersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UsersResponse> {
        const response = await this.getMutedUsersRaw(params, initOverrides);
        return await response.value();
    }

    /**
     * @hidden
     * Get intersection of users that follow followeeUserId and users that are followed by followerUserId
     */
    async getMutualFollowersRaw(params: GetMutualFollowersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MutualFollowersResponse>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getMutualFollowers.');
        }

        const queryParameters: any = {};

        if (params.offset !== undefined) {
            queryParameters['offset'] = params.offset;
        }

        if (params.limit !== undefined) {
            queryParameters['limit'] = params.limit;
        }

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/mutuals`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MutualFollowersResponseFromJSON(jsonValue));
    }

    /**
     * Get intersection of users that follow followeeUserId and users that are followed by followerUserId
     */
    async getMutualFollowers(params: GetMutualFollowersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MutualFollowersResponse> {
        const response = await this.getMutualFollowersRaw(params, initOverrides);
        return await response.value();
    }

    /**
     * @hidden
     * Gets the playlists created by a user using their user ID
     */
    async getPlaylistsByUserRaw(params: GetPlaylistsByUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PlaylistsResponse>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getPlaylistsByUser.');
        }

        const queryParameters: any = {};

        if (params.offset !== undefined) {
            queryParameters['offset'] = params.offset;
        }

        if (params.limit !== undefined) {
            queryParameters['limit'] = params.limit;
        }

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
            headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
        }

        if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
            headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
        }

        const response = await this.request({
            path: `/users/{id}/playlists`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PlaylistsResponseFromJSON(jsonValue));
    }

    /**
     * Gets the playlists created by a user using their user ID
     */
    async getPlaylistsByUser(params: GetPlaylistsByUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PlaylistsResponse> {
        const response = await this.getPlaylistsByUserRaw(params, initOverrides);
        return await response.value();
    }

    /**
     * @hidden
     * Gets the list of unique users who have purchased content by the given user
     */
    async getPurchasersRaw(params: GetPurchasersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PurchasersResponse>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getPurchasers.');
        }

        const queryParameters: any = {};

        if (params.offset !== undefined) {
            queryParameters['offset'] = params.offset;
        }

        if (params.limit !== undefined) {
            queryParameters['limit'] = params.limit;
        }

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        if (params.contentType !== undefined) {
            queryParameters['content_type'] = params.contentType;
        }

        if (params.contentId !== undefined) {
            queryParameters['content_id'] = params.contentId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/purchasers`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PurchasersResponseFromJSON(jsonValue));
    }

    /**
     * Gets the list of unique users who have purchased content by the given user
     */
    async getPurchasers(params: GetPurchasersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PurchasersResponse> {
        const response = await this.getPurchasersRaw(params, initOverrides);
        return await response.value();
    }

    /**
     * @hidden
     * Gets a list of users that might be of interest to followers of this user.
     */
    async getRelatedUsersRaw(params: GetRelatedUsersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RelatedArtistResponse>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getRelatedUsers.');
        }

        const queryParameters: any = {};

        if (params.offset !== undefined) {
            queryParameters['offset'] = params.offset;
        }

        if (params.limit !== undefined) {
            queryParameters['limit'] = params.limit;
        }

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/related`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RelatedArtistResponseFromJSON(jsonValue));
    }

    /**
     * Gets a list of users that might be of interest to followers of this user.
     */
    async getRelatedUsers(params: GetRelatedUsersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RelatedArtistResponse> {
        const response = await this.getRelatedUsersRaw(params, initOverrides);
        return await response.value();
    }

    /**
     * @hidden
     * Gets the list of unique users who have remixed tracks by the given user, or a specific track by that user if provided
     */
    async getRemixersRaw(params: GetRemixersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RemixersResponse>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getRemixers.');
        }

        const queryParameters: any = {};

        if (params.offset !== undefined) {
            queryParameters['offset'] = params.offset;
        }

        if (params.limit !== undefined) {
            queryParameters['limit'] = params.limit;
        }

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        if (params.trackId !== undefined) {
            queryParameters['track_id'] = params.trackId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/remixers`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RemixersResponseFromJSON(jsonValue));
    }

    /**
     * Gets the list of unique users who have remixed tracks by the given user, or a specific track by that user if provided
     */
    async getRemixers(params: GetRemixersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RemixersResponse> {
        const response = await this.getRemixersRaw(params, initOverrides);
        return await response.value();
    }

    /**
     * @hidden
     * Gets the given user\'s reposts
     */
    async getRepostsRaw(params: GetRepostsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Reposts>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getReposts.');
        }

        const queryParameters: any = {};

        if (params.offset !== undefined) {
            queryParameters['offset'] = params.offset;
        }

        if (params.limit !== undefined) {
            queryParameters['limit'] = params.limit;
        }

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/reposts`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RepostsFromJSON(jsonValue));
    }

    /**
     * Gets the given user\'s reposts
     */
    async getReposts(params: GetRepostsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Reposts> {
        const response = await this.getRepostsRaw(params, initOverrides);
        return await response.value();
    }

    /**
     * @hidden
     * Gets the aggregated sales data for the user
     */
    async getSalesAggregateRaw(params: GetSalesAggregateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SalesAggregateResponse>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getSalesAggregate.');
        }

        const queryParameters: any = {};

        if (params.offset !== undefined) {
            queryParameters['offset'] = params.offset;
        }

        if (params.limit !== undefined) {
            queryParameters['limit'] = params.limit;
        }

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
            headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
        }

        if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
            headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
        }

        const response = await this.request({
            path: `/users/{id}/sales/aggregate`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SalesAggregateResponseFromJSON(jsonValue));
    }

    /**
     * Gets the aggregated sales data for the user
     */
    async getSalesAggregate(params: GetSalesAggregateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SalesAggregateResponse> {
        const response = await this.getSalesAggregateRaw(params, initOverrides);
        return await response.value();
    }

    /**
     * @hidden
     * All users that subscribe to the provided user
     */
    async getSubscribersRaw(params: GetSubscribersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SubscribersResponse>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getSubscribers.');
        }

        const queryParameters: any = {};

        if (params.offset !== undefined) {
            queryParameters['offset'] = params.offset;
        }

        if (params.limit !== undefined) {
            queryParameters['limit'] = params.limit;
        }

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/subscribers`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SubscribersResponseFromJSON(jsonValue));
    }

    /**
     * All users that subscribe to the provided user
     */
    async getSubscribers(params: GetSubscribersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SubscribersResponse> {
        const response = await this.getSubscribersRaw(params, initOverrides);
        return await response.value();
    }

    /**
     * @hidden
     * Gets the users that the given user supports
     */
    async getSupportedUsersRaw(params: GetSupportedUsersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetSupportedUsers>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getSupportedUsers.');
        }

        const queryParameters: any = {};

        if (params.offset !== undefined) {
            queryParameters['offset'] = params.offset;
        }

        if (params.limit !== undefined) {
            queryParameters['limit'] = params.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/supporting`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetSupportedUsersFromJSON(jsonValue));
    }

    /**
     * Gets the users that the given user supports
     */
    async getSupportedUsers(params: GetSupportedUsersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetSupportedUsers> {
        const response = await this.getSupportedUsersRaw(params, initOverrides);
        return await response.value();
    }

    /**
     * @hidden
     * Gets the supporters of the given user
     */
    async getSupportersRaw(params: GetSupportersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetSupporters>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getSupporters.');
        }

        const queryParameters: any = {};

        if (params.offset !== undefined) {
            queryParameters['offset'] = params.offset;
        }

        if (params.limit !== undefined) {
            queryParameters['limit'] = params.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/supporters`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetSupportersFromJSON(jsonValue));
    }

    /**
     * Gets the supporters of the given user
     */
    async getSupporters(params: GetSupportersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetSupporters> {
        const response = await this.getSupportersRaw(params, initOverrides);
        return await response.value();
    }

    /**
     * @hidden
     * Gets the most used track tags by a user.
     * Fetch most used tags in a user\'s tracks
     */
    async getTopTrackTagsRaw(params: GetTopTrackTagsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TagsResponse>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getTopTrackTags.');
        }

        const queryParameters: any = {};

        if (params.limit !== undefined) {
            queryParameters['limit'] = params.limit;
        }

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/tags`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TagsResponseFromJSON(jsonValue));
    }

    /**
     * Gets the most used track tags by a user.
     * Fetch most used tags in a user\'s tracks
     */
    async getTopTrackTags(params: GetTopTrackTagsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TagsResponse> {
        const response = await this.getTopTrackTagsRaw(params, initOverrides);
        return await response.value();
    }

    /**
     * @hidden
     * Gets the tracks created by a user using their user ID
     */
    async getTracksByUserRaw(params: GetTracksByUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TracksResponse>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getTracksByUser.');
        }

        const queryParameters: any = {};

        if (params.offset !== undefined) {
            queryParameters['offset'] = params.offset;
        }

        if (params.limit !== undefined) {
            queryParameters['limit'] = params.limit;
        }

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        if (params.sort !== undefined) {
            queryParameters['sort'] = params.sort;
        }

        if (params.query !== undefined) {
            queryParameters['query'] = params.query;
        }

        if (params.sortMethod !== undefined) {
            queryParameters['sort_method'] = params.sortMethod;
        }

        if (params.sortDirection !== undefined) {
            queryParameters['sort_direction'] = params.sortDirection;
        }

        if (params.filterTracks !== undefined) {
            queryParameters['filter_tracks'] = params.filterTracks;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (params.encodedDataMessage !== undefined && params.encodedDataMessage !== null) {
            headerParameters['Encoded-Data-Message'] = String(params.encodedDataMessage);
        }

        if (params.encodedDataSignature !== undefined && params.encodedDataSignature !== null) {
            headerParameters['Encoded-Data-Signature'] = String(params.encodedDataSignature);
        }

        const response = await this.request({
            path: `/users/{id}/tracks`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TracksResponseFromJSON(jsonValue));
    }

    /**
     * Gets the tracks created by a user using their user ID
     */
    async getTracksByUser(params: GetTracksByUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TracksResponse> {
        const response = await this.getTracksByUserRaw(params, initOverrides);
        return await response.value();
    }

    /**
     * @hidden
     * Gets a single user by their user ID
     */
    async getUserRaw(params: GetUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserResponse>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getUser.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserResponseFromJSON(jsonValue));
    }

    /**
     * Gets a single user by their user ID
     */
    async getUser(params: GetUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserResponse> {
        const response = await this.getUserRaw(params, initOverrides);
        return await response.value();
    }

    /**
     * @hidden
     * Gets a single user by their handle
     */
    async getUserByHandleRaw(params: GetUserByHandleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserResponse>> {
        if (params.handle === null || params.handle === undefined) {
            throw new runtime.RequiredError('handle','Required parameter params.handle was null or undefined when calling getUserByHandle.');
        }

        const queryParameters: any = {};

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/handle/{handle}`.replace(`{${"handle"}}`, encodeURIComponent(String(params.handle))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserResponseFromJSON(jsonValue));
    }

    /**
     * Gets a single user by their handle
     */
    async getUserByHandle(params: GetUserByHandleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserResponse> {
        const response = await this.getUserByHandleRaw(params, initOverrides);
        return await response.value();
    }

    /**
     * @hidden
     * Gets all challenges for the given user
     */
    async getUserChallengesRaw(params: GetUserChallengesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetChallenges>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getUserChallenges.');
        }

        const queryParameters: any = {};

        if (params.showHistorical !== undefined) {
            queryParameters['show_historical'] = params.showHistorical;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/challenges`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetChallengesFromJSON(jsonValue));
    }

    /**
     * Gets all challenges for the given user
     */
    async getUserChallenges(params: GetUserChallengesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetChallenges> {
        const response = await this.getUserChallengesRaw(params, initOverrides);
        return await response.value();
    }

    /**
     * @hidden
     * Gets the email encryption key for a user by their user ID
     * Get the email encryption key for a user
     */
    async getUserEmailKeyRaw(params: GetUserEmailKeyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EmailKeyResponse>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getUserEmailKey.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/emails/key`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EmailKeyResponseFromJSON(jsonValue));
    }

    /**
     * Gets the email encryption key for a user by their user ID
     * Get the email encryption key for a user
     */
    async getUserEmailKey(params: GetUserEmailKeyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EmailKeyResponse> {
        const response = await this.getUserEmailKeyRaw(params, initOverrides);
        return await response.value();
    }

    /**
     * @hidden
     * Gets a User ID from an associated wallet address
     */
    async getUserIDFromWalletRaw(params: GetUserIDFromWalletRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserAssociatedWalletResponse>> {
        if (params.associatedWallet === null || params.associatedWallet === undefined) {
            throw new runtime.RequiredError('associatedWallet','Required parameter params.associatedWallet was null or undefined when calling getUserIDFromWallet.');
        }

        const queryParameters: any = {};

        if (params.associatedWallet !== undefined) {
            queryParameters['associated_wallet'] = params.associatedWallet;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/id`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserAssociatedWalletResponseFromJSON(jsonValue));
    }

    /**
     * Gets a User ID from an associated wallet address
     */
    async getUserIDFromWallet(params: GetUserIDFromWalletRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserAssociatedWalletResponse> {
        const response = await this.getUserIDFromWalletRaw(params, initOverrides);
        return await response.value();
    }

    /**
     * @hidden
     * Gets the listen data for a user by month and track within a given time frame.
     */
    async getUserMonthlyTrackListensRaw(params: GetUserMonthlyTrackListensRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserTrackListenCountsResponse>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getUserMonthlyTrackListens.');
        }

        if (params.startTime === null || params.startTime === undefined) {
            throw new runtime.RequiredError('startTime','Required parameter params.startTime was null or undefined when calling getUserMonthlyTrackListens.');
        }

        if (params.endTime === null || params.endTime === undefined) {
            throw new runtime.RequiredError('endTime','Required parameter params.endTime was null or undefined when calling getUserMonthlyTrackListens.');
        }

        const queryParameters: any = {};

        if (params.startTime !== undefined) {
            queryParameters['start_time'] = params.startTime;
        }

        if (params.endTime !== undefined) {
            queryParameters['end_time'] = params.endTime;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/listen_counts_monthly`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserTrackListenCountsResponseFromJSON(jsonValue));
    }

    /**
     * Gets the listen data for a user by month and track within a given time frame.
     */
    async getUserMonthlyTrackListens(params: GetUserMonthlyTrackListensRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserTrackListenCountsResponse> {
        const response = await this.getUserMonthlyTrackListensRaw(params, initOverrides);
        return await response.value();
    }

    /**
     * @hidden
     * Gets tracks owned by the user which have been remixed by another track
     */
    async getUserTracksRemixedRaw(params: GetUserTracksRemixedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserTracksRemixedResponse>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getUserTracksRemixed.');
        }

        const queryParameters: any = {};

        if (params.offset !== undefined) {
            queryParameters['offset'] = params.offset;
        }

        if (params.limit !== undefined) {
            queryParameters['limit'] = params.limit;
        }

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/tracks/remixed`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserTracksRemixedResponseFromJSON(jsonValue));
    }

    /**
     * Gets tracks owned by the user which have been remixed by another track
     */
    async getUserTracksRemixed(params: GetUserTracksRemixedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserTracksRemixedResponse> {
        const response = await this.getUserTracksRemixedRaw(params, initOverrides);
        return await response.value();
    }

    /**
     * @hidden
     * Search for users that match the given query
     */
    async searchUsersRaw(params: SearchUsersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserSearch>> {
        const queryParameters: any = {};

        if (params.query !== undefined) {
            queryParameters['query'] = params.query;
        }

        if (params.genre) {
            queryParameters['genre'] = params.genre;
        }

        if (params.sortMethod !== undefined) {
            queryParameters['sort_method'] = params.sortMethod;
        }

        if (params.isVerified !== undefined) {
            queryParameters['is_verified'] = params.isVerified;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/search`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserSearchFromJSON(jsonValue));
    }

    /**
     * Search for users that match the given query
     */
    async searchUsers(params: SearchUsersRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserSearch> {
        const response = await this.searchUsersRaw(params, initOverrides);
        return await response.value();
    }

    /**
     * @hidden
     * Verify if the given jwt ID token was signed by the subject (user) in the payload
     */
    async verifyIDTokenRaw(params: VerifyIDTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<VerifyToken>> {
        if (params.token === null || params.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter params.token was null or undefined when calling verifyIDToken.');
        }

        const queryParameters: any = {};

        if (params.token !== undefined) {
            queryParameters['token'] = params.token;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/verify_token`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => VerifyTokenFromJSON(jsonValue));
    }

    /**
     * Verify if the given jwt ID token was signed by the subject (user) in the payload
     */
    async verifyIDToken(params: VerifyIDTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<VerifyToken> {
        const response = await this.verifyIDTokenRaw(params, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const GetAIAttributedTracksByUserHandleSortEnum = {
    Date: 'date',
    Plays: 'plays'
} as const;
export type GetAIAttributedTracksByUserHandleSortEnum = typeof GetAIAttributedTracksByUserHandleSortEnum[keyof typeof GetAIAttributedTracksByUserHandleSortEnum];
/**
 * @export
 */
export const GetAIAttributedTracksByUserHandleSortMethodEnum = {
    Title: 'title',
    ArtistName: 'artist_name',
    ReleaseDate: 'release_date',
    LastListenDate: 'last_listen_date',
    AddedDate: 'added_date',
    Plays: 'plays',
    Reposts: 'reposts',
    Saves: 'saves',
    MostListensByUser: 'most_listens_by_user'
} as const;
export type GetAIAttributedTracksByUserHandleSortMethodEnum = typeof GetAIAttributedTracksByUserHandleSortMethodEnum[keyof typeof GetAIAttributedTracksByUserHandleSortMethodEnum];
/**
 * @export
 */
export const GetAIAttributedTracksByUserHandleSortDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type GetAIAttributedTracksByUserHandleSortDirectionEnum = typeof GetAIAttributedTracksByUserHandleSortDirectionEnum[keyof typeof GetAIAttributedTracksByUserHandleSortDirectionEnum];
/**
 * @export
 */
export const GetAIAttributedTracksByUserHandleFilterTracksEnum = {
    All: 'all',
    Public: 'public',
    Unlisted: 'unlisted'
} as const;
export type GetAIAttributedTracksByUserHandleFilterTracksEnum = typeof GetAIAttributedTracksByUserHandleFilterTracksEnum[keyof typeof GetAIAttributedTracksByUserHandleFilterTracksEnum];
/**
 * @export
 */
export const GetTracksByUserSortEnum = {
    Date: 'date',
    Plays: 'plays'
} as const;
export type GetTracksByUserSortEnum = typeof GetTracksByUserSortEnum[keyof typeof GetTracksByUserSortEnum];
/**
 * @export
 */
export const GetTracksByUserSortMethodEnum = {
    Title: 'title',
    ArtistName: 'artist_name',
    ReleaseDate: 'release_date',
    LastListenDate: 'last_listen_date',
    AddedDate: 'added_date',
    Plays: 'plays',
    Reposts: 'reposts',
    Saves: 'saves',
    MostListensByUser: 'most_listens_by_user'
} as const;
export type GetTracksByUserSortMethodEnum = typeof GetTracksByUserSortMethodEnum[keyof typeof GetTracksByUserSortMethodEnum];
/**
 * @export
 */
export const GetTracksByUserSortDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type GetTracksByUserSortDirectionEnum = typeof GetTracksByUserSortDirectionEnum[keyof typeof GetTracksByUserSortDirectionEnum];
/**
 * @export
 */
export const GetTracksByUserFilterTracksEnum = {
    All: 'all',
    Public: 'public',
    Unlisted: 'unlisted'
} as const;
export type GetTracksByUserFilterTracksEnum = typeof GetTracksByUserFilterTracksEnum[keyof typeof GetTracksByUserFilterTracksEnum];
/**
 * @export
 */
export const SearchUsersSortMethodEnum = {
    Relevant: 'relevant',
    Popular: 'popular',
    Recent: 'recent'
} as const;
export type SearchUsersSortMethodEnum = typeof SearchUsersSortMethodEnum[keyof typeof SearchUsersSortMethodEnum];
