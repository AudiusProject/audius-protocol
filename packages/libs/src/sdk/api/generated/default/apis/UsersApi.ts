/* tslint:disable */
// @ts-nocheck
/* eslint-disable */
/**
 * API
 * Audius V1 API
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AuthorizedApps,
  ConnectedWalletsResponse,
  DeveloperApps,
  FavoritesResponse,
  FollowersResponse,
  FollowingResponse,
  GetSupporters,
  GetSupporting,
  RelatedArtistResponse,
  Reposts,
  SubscribersResponse,
  TagsResponse,
  TracksResponse,
  UserAssociatedWalletResponse,
  UserResponse,
  UserSearch,
  VerifyToken,
} from '../models';
import {
    AuthorizedAppsFromJSON,
    AuthorizedAppsToJSON,
    ConnectedWalletsResponseFromJSON,
    ConnectedWalletsResponseToJSON,
    DeveloperAppsFromJSON,
    DeveloperAppsToJSON,
    FavoritesResponseFromJSON,
    FavoritesResponseToJSON,
    FollowersResponseFromJSON,
    FollowersResponseToJSON,
    FollowingResponseFromJSON,
    FollowingResponseToJSON,
    GetSupportersFromJSON,
    GetSupportersToJSON,
    GetSupportingFromJSON,
    GetSupportingToJSON,
    RelatedArtistResponseFromJSON,
    RelatedArtistResponseToJSON,
    RepostsFromJSON,
    RepostsToJSON,
    SubscribersResponseFromJSON,
    SubscribersResponseToJSON,
    TagsResponseFromJSON,
    TagsResponseToJSON,
    TracksResponseFromJSON,
    TracksResponseToJSON,
    UserAssociatedWalletResponseFromJSON,
    UserAssociatedWalletResponseToJSON,
    UserResponseFromJSON,
    UserResponseToJSON,
    UserSearchFromJSON,
    UserSearchToJSON,
    VerifyTokenFromJSON,
    VerifyTokenToJSON,
} from '../models';

export interface DownloadPurchasesAsCSVRequest {
    id: string;
    userId?: string;
}

export interface DownloadSalesAsCSVRequest {
    id: string;
    userId?: string;
}

export interface DownloadUSDCWithdrawalsAsCSVRequest {
    id: string;
    userId?: string;
}

export interface GetAIAttributedTracksByUserHandleRequest {
    handle: string;
    offset?: number;
    limit?: number;
    userId?: string;
    sort?: GetAIAttributedTracksByUserHandleSortEnum;
    query?: string;
    sortMethod?: GetAIAttributedTracksByUserHandleSortMethodEnum;
    sortDirection?: GetAIAttributedTracksByUserHandleSortDirectionEnum;
    filterTracks?: GetAIAttributedTracksByUserHandleFilterTracksEnum;
}

export interface GetAuthorizedAppsRequest {
    id: string;
}

export interface GetConnectedWalletsRequest {
    id: string;
}

export interface GetDeveloperAppsRequest {
    id: string;
}

export interface GetFavoritesRequest {
    id: string;
}

export interface GetFollowersRequest {
    id: string;
    offset?: number;
    limit?: number;
    userId?: string;
}

export interface GetFollowingRequest {
    id: string;
    offset?: number;
    limit?: number;
    userId?: string;
}

export interface GetRelatedUsersRequest {
    id: string;
    offset?: number;
    limit?: number;
    userId?: string;
}

export interface GetRepostsRequest {
    id: string;
    offset?: number;
    limit?: number;
    userId?: string;
}

export interface GetSubscribersRequest {
    id: string;
    offset?: number;
    limit?: number;
    userId?: string;
}

export interface GetSupportersRequest {
    id: string;
    offset?: number;
    limit?: number;
}

export interface GetSupportingsRequest {
    id: string;
    offset?: number;
    limit?: number;
}

export interface GetTopTrackTagsRequest {
    id: string;
    limit?: number;
    userId?: string;
}

export interface GetTracksByUserRequest {
    id: string;
    offset?: number;
    limit?: number;
    userId?: string;
    sort?: GetTracksByUserSortEnum;
    query?: string;
    sortMethod?: GetTracksByUserSortMethodEnum;
    sortDirection?: GetTracksByUserSortDirectionEnum;
    filterTracks?: GetTracksByUserFilterTracksEnum;
}

export interface GetUserRequest {
    id: string;
}

export interface GetUserByHandleRequest {
    handle: string;
    userId?: string;
}

export interface GetUserIDFromWalletRequest {
    associatedWallet: string;
}

export interface SearchUsersRequest {
    query: string;
}

export interface VerifyIDTokenRequest {
    token: string;
}

/**
 * 
 */
export class UsersApi extends runtime.BaseAPI {

    /**
     * @hidden
     * Downloads the purchases the user has made as a CSV file
     */
    async downloadPurchasesAsCSVRaw(params: DownloadPurchasesAsCSVRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling downloadPurchasesAsCSV.');
        }

        const queryParameters: any = {};

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/purchases/download`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Downloads the purchases the user has made as a CSV file
     */
    async downloadPurchasesAsCSV(params: DownloadPurchasesAsCSVRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.downloadPurchasesAsCSVRaw(params, initOverrides);
    }

    /**
     * @hidden
     * Downloads the sales the user has made as a CSV file
     */
    async downloadSalesAsCSVRaw(params: DownloadSalesAsCSVRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling downloadSalesAsCSV.');
        }

        const queryParameters: any = {};

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/sales/download`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Downloads the sales the user has made as a CSV file
     */
    async downloadSalesAsCSV(params: DownloadSalesAsCSVRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.downloadSalesAsCSVRaw(params, initOverrides);
    }

    /**
     * @hidden
     * Downloads the USDC withdrawals the user has made as a CSV file
     */
    async downloadUSDCWithdrawalsAsCSVRaw(params: DownloadUSDCWithdrawalsAsCSVRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling downloadUSDCWithdrawalsAsCSV.');
        }

        const queryParameters: any = {};

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/withdrawals/download`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Downloads the USDC withdrawals the user has made as a CSV file
     */
    async downloadUSDCWithdrawalsAsCSV(params: DownloadUSDCWithdrawalsAsCSVRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.downloadUSDCWithdrawalsAsCSVRaw(params, initOverrides);
    }

    /**
     * @hidden
     * Gets the AI generated tracks attributed to a user using the user\'s handle
     */
    async getAIAttributedTracksByUserHandleRaw(params: GetAIAttributedTracksByUserHandleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TracksResponse>> {
        if (params.handle === null || params.handle === undefined) {
            throw new runtime.RequiredError('handle','Required parameter params.handle was null or undefined when calling getAIAttributedTracksByUserHandle.');
        }

        const queryParameters: any = {};

        if (params.offset !== undefined) {
            queryParameters['offset'] = params.offset;
        }

        if (params.limit !== undefined) {
            queryParameters['limit'] = params.limit;
        }

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        if (params.sort !== undefined) {
            queryParameters['sort'] = params.sort;
        }

        if (params.query !== undefined) {
            queryParameters['query'] = params.query;
        }

        if (params.sortMethod !== undefined) {
            queryParameters['sort_method'] = params.sortMethod;
        }

        if (params.sortDirection !== undefined) {
            queryParameters['sort_direction'] = params.sortDirection;
        }

        if (params.filterTracks !== undefined) {
            queryParameters['filter_tracks'] = params.filterTracks;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/handle/{handle}/tracks/ai_attributed`.replace(`{${"handle"}}`, encodeURIComponent(String(params.handle))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TracksResponseFromJSON(jsonValue));
    }

    /**
     * Gets the AI generated tracks attributed to a user using the user\'s handle
     */
    async getAIAttributedTracksByUserHandle(params: GetAIAttributedTracksByUserHandleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TracksResponse> {
        const response = await this.getAIAttributedTracksByUserHandleRaw(params, initOverrides);
        return await response.value();
    }

    /**
     * @hidden
     * Get the apps that user has authorized to write to their account
     */
    async getAuthorizedAppsRaw(params: GetAuthorizedAppsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthorizedApps>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getAuthorizedApps.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/authorized_apps`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AuthorizedAppsFromJSON(jsonValue));
    }

    /**
     * Get the apps that user has authorized to write to their account
     */
    async getAuthorizedApps(params: GetAuthorizedAppsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthorizedApps> {
        const response = await this.getAuthorizedAppsRaw(params, initOverrides);
        return await response.value();
    }

    /**
     * @hidden
     * Get the User\'s ERC and SPL connected wallets
     */
    async getConnectedWalletsRaw(params: GetConnectedWalletsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConnectedWalletsResponse>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getConnectedWallets.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/connected_wallets`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConnectedWalletsResponseFromJSON(jsonValue));
    }

    /**
     * Get the User\'s ERC and SPL connected wallets
     */
    async getConnectedWallets(params: GetConnectedWalletsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConnectedWalletsResponse> {
        const response = await this.getConnectedWalletsRaw(params, initOverrides);
        return await response.value();
    }

    /**
     * @hidden
     * Gets the developer apps that the user owns
     */
    async getDeveloperAppsRaw(params: GetDeveloperAppsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeveloperApps>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getDeveloperApps.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/developer_apps`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DeveloperAppsFromJSON(jsonValue));
    }

    /**
     * Gets the developer apps that the user owns
     */
    async getDeveloperApps(params: GetDeveloperAppsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeveloperApps> {
        const response = await this.getDeveloperAppsRaw(params, initOverrides);
        return await response.value();
    }

    /**
     * @hidden
     * Gets a user\'s favorite tracks
     */
    async getFavoritesRaw(params: GetFavoritesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FavoritesResponse>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getFavorites.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/favorites`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FavoritesResponseFromJSON(jsonValue));
    }

    /**
     * Gets a user\'s favorite tracks
     */
    async getFavorites(params: GetFavoritesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FavoritesResponse> {
        const response = await this.getFavoritesRaw(params, initOverrides);
        return await response.value();
    }

    /**
     * @hidden
     * All users that follow the provided user
     */
    async getFollowersRaw(params: GetFollowersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FollowersResponse>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getFollowers.');
        }

        const queryParameters: any = {};

        if (params.offset !== undefined) {
            queryParameters['offset'] = params.offset;
        }

        if (params.limit !== undefined) {
            queryParameters['limit'] = params.limit;
        }

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/followers`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FollowersResponseFromJSON(jsonValue));
    }

    /**
     * All users that follow the provided user
     */
    async getFollowers(params: GetFollowersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FollowersResponse> {
        const response = await this.getFollowersRaw(params, initOverrides);
        return await response.value();
    }

    /**
     * @hidden
     * All users that the provided user follows
     */
    async getFollowingRaw(params: GetFollowingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FollowingResponse>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getFollowing.');
        }

        const queryParameters: any = {};

        if (params.offset !== undefined) {
            queryParameters['offset'] = params.offset;
        }

        if (params.limit !== undefined) {
            queryParameters['limit'] = params.limit;
        }

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/following`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FollowingResponseFromJSON(jsonValue));
    }

    /**
     * All users that the provided user follows
     */
    async getFollowing(params: GetFollowingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FollowingResponse> {
        const response = await this.getFollowingRaw(params, initOverrides);
        return await response.value();
    }

    /**
     * @hidden
     * Gets a list of users that might be of interest to followers of this user.
     */
    async getRelatedUsersRaw(params: GetRelatedUsersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RelatedArtistResponse>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getRelatedUsers.');
        }

        const queryParameters: any = {};

        if (params.offset !== undefined) {
            queryParameters['offset'] = params.offset;
        }

        if (params.limit !== undefined) {
            queryParameters['limit'] = params.limit;
        }

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/related`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RelatedArtistResponseFromJSON(jsonValue));
    }

    /**
     * Gets a list of users that might be of interest to followers of this user.
     */
    async getRelatedUsers(params: GetRelatedUsersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RelatedArtistResponse> {
        const response = await this.getRelatedUsersRaw(params, initOverrides);
        return await response.value();
    }

    /**
     * @hidden
     * Gets the given user\'s reposts
     */
    async getRepostsRaw(params: GetRepostsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Reposts>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getReposts.');
        }

        const queryParameters: any = {};

        if (params.offset !== undefined) {
            queryParameters['offset'] = params.offset;
        }

        if (params.limit !== undefined) {
            queryParameters['limit'] = params.limit;
        }

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/reposts`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RepostsFromJSON(jsonValue));
    }

    /**
     * Gets the given user\'s reposts
     */
    async getReposts(params: GetRepostsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Reposts> {
        const response = await this.getRepostsRaw(params, initOverrides);
        return await response.value();
    }

    /**
     * @hidden
     * All users that subscribe to the provided user
     */
    async getSubscribersRaw(params: GetSubscribersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SubscribersResponse>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getSubscribers.');
        }

        const queryParameters: any = {};

        if (params.offset !== undefined) {
            queryParameters['offset'] = params.offset;
        }

        if (params.limit !== undefined) {
            queryParameters['limit'] = params.limit;
        }

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/subscribers`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SubscribersResponseFromJSON(jsonValue));
    }

    /**
     * All users that subscribe to the provided user
     */
    async getSubscribers(params: GetSubscribersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SubscribersResponse> {
        const response = await this.getSubscribersRaw(params, initOverrides);
        return await response.value();
    }

    /**
     * @hidden
     * Gets the supporters of the given user
     */
    async getSupportersRaw(params: GetSupportersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetSupporters>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getSupporters.');
        }

        const queryParameters: any = {};

        if (params.offset !== undefined) {
            queryParameters['offset'] = params.offset;
        }

        if (params.limit !== undefined) {
            queryParameters['limit'] = params.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/supporters`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetSupportersFromJSON(jsonValue));
    }

    /**
     * Gets the supporters of the given user
     */
    async getSupporters(params: GetSupportersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetSupporters> {
        const response = await this.getSupportersRaw(params, initOverrides);
        return await response.value();
    }

    /**
     * @hidden
     * Gets the users that the given user supports
     */
    async getSupportingsRaw(params: GetSupportingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetSupporting>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getSupportings.');
        }

        const queryParameters: any = {};

        if (params.offset !== undefined) {
            queryParameters['offset'] = params.offset;
        }

        if (params.limit !== undefined) {
            queryParameters['limit'] = params.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/supporting`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetSupportingFromJSON(jsonValue));
    }

    /**
     * Gets the users that the given user supports
     */
    async getSupportings(params: GetSupportingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetSupporting> {
        const response = await this.getSupportingsRaw(params, initOverrides);
        return await response.value();
    }

    /**
     * @hidden
     * Gets the most used track tags by a user.
     * Fetch most used tags in a user\'s tracks
     */
    async getTopTrackTagsRaw(params: GetTopTrackTagsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TagsResponse>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getTopTrackTags.');
        }

        const queryParameters: any = {};

        if (params.limit !== undefined) {
            queryParameters['limit'] = params.limit;
        }

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/tags`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TagsResponseFromJSON(jsonValue));
    }

    /**
     * Gets the most used track tags by a user.
     * Fetch most used tags in a user\'s tracks
     */
    async getTopTrackTags(params: GetTopTrackTagsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TagsResponse> {
        const response = await this.getTopTrackTagsRaw(params, initOverrides);
        return await response.value();
    }

    /**
     * @hidden
     * Gets the tracks created by a user using their user ID
     */
    async getTracksByUserRaw(params: GetTracksByUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TracksResponse>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getTracksByUser.');
        }

        const queryParameters: any = {};

        if (params.offset !== undefined) {
            queryParameters['offset'] = params.offset;
        }

        if (params.limit !== undefined) {
            queryParameters['limit'] = params.limit;
        }

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        if (params.sort !== undefined) {
            queryParameters['sort'] = params.sort;
        }

        if (params.query !== undefined) {
            queryParameters['query'] = params.query;
        }

        if (params.sortMethod !== undefined) {
            queryParameters['sort_method'] = params.sortMethod;
        }

        if (params.sortDirection !== undefined) {
            queryParameters['sort_direction'] = params.sortDirection;
        }

        if (params.filterTracks !== undefined) {
            queryParameters['filter_tracks'] = params.filterTracks;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}/tracks`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TracksResponseFromJSON(jsonValue));
    }

    /**
     * Gets the tracks created by a user using their user ID
     */
    async getTracksByUser(params: GetTracksByUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TracksResponse> {
        const response = await this.getTracksByUserRaw(params, initOverrides);
        return await response.value();
    }

    /**
     * @hidden
     * Gets a single user by their user ID
     */
    async getUserRaw(params: GetUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserResponse>> {
        if (params.id === null || params.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter params.id was null or undefined when calling getUser.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(params.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserResponseFromJSON(jsonValue));
    }

    /**
     * Gets a single user by their user ID
     */
    async getUser(params: GetUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserResponse> {
        const response = await this.getUserRaw(params, initOverrides);
        return await response.value();
    }

    /**
     * @hidden
     * Gets a single user by their handle
     */
    async getUserByHandleRaw(params: GetUserByHandleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserResponse>> {
        if (params.handle === null || params.handle === undefined) {
            throw new runtime.RequiredError('handle','Required parameter params.handle was null or undefined when calling getUserByHandle.');
        }

        const queryParameters: any = {};

        if (params.userId !== undefined) {
            queryParameters['user_id'] = params.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/handle/{handle}`.replace(`{${"handle"}}`, encodeURIComponent(String(params.handle))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserResponseFromJSON(jsonValue));
    }

    /**
     * Gets a single user by their handle
     */
    async getUserByHandle(params: GetUserByHandleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserResponse> {
        const response = await this.getUserByHandleRaw(params, initOverrides);
        return await response.value();
    }

    /**
     * @hidden
     * Gets a User ID from an associated wallet address
     */
    async getUserIDFromWalletRaw(params: GetUserIDFromWalletRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserAssociatedWalletResponse>> {
        if (params.associatedWallet === null || params.associatedWallet === undefined) {
            throw new runtime.RequiredError('associatedWallet','Required parameter params.associatedWallet was null or undefined when calling getUserIDFromWallet.');
        }

        const queryParameters: any = {};

        if (params.associatedWallet !== undefined) {
            queryParameters['associated_wallet'] = params.associatedWallet;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/id`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserAssociatedWalletResponseFromJSON(jsonValue));
    }

    /**
     * Gets a User ID from an associated wallet address
     */
    async getUserIDFromWallet(params: GetUserIDFromWalletRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserAssociatedWalletResponse> {
        const response = await this.getUserIDFromWalletRaw(params, initOverrides);
        return await response.value();
    }

    /**
     * @hidden
     * Search for users that match the given query
     */
    async searchUsersRaw(params: SearchUsersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserSearch>> {
        if (params.query === null || params.query === undefined) {
            throw new runtime.RequiredError('query','Required parameter params.query was null or undefined when calling searchUsers.');
        }

        const queryParameters: any = {};

        if (params.query !== undefined) {
            queryParameters['query'] = params.query;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/search`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserSearchFromJSON(jsonValue));
    }

    /**
     * Search for users that match the given query
     */
    async searchUsers(params: SearchUsersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserSearch> {
        const response = await this.searchUsersRaw(params, initOverrides);
        return await response.value();
    }

    /**
     * @hidden
     * Verify if the given jwt ID token was signed by the subject (user) in the payload
     */
    async verifyIDTokenRaw(params: VerifyIDTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<VerifyToken>> {
        if (params.token === null || params.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter params.token was null or undefined when calling verifyIDToken.');
        }

        const queryParameters: any = {};

        if (params.token !== undefined) {
            queryParameters['token'] = params.token;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/verify_token`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => VerifyTokenFromJSON(jsonValue));
    }

    /**
     * Verify if the given jwt ID token was signed by the subject (user) in the payload
     */
    async verifyIDToken(params: VerifyIDTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<VerifyToken> {
        const response = await this.verifyIDTokenRaw(params, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const GetAIAttributedTracksByUserHandleSortEnum = {
    Date: 'date',
    Plays: 'plays'
} as const;
export type GetAIAttributedTracksByUserHandleSortEnum = typeof GetAIAttributedTracksByUserHandleSortEnum[keyof typeof GetAIAttributedTracksByUserHandleSortEnum];
/**
 * @export
 */
export const GetAIAttributedTracksByUserHandleSortMethodEnum = {
    Title: 'title',
    ArtistName: 'artist_name',
    ReleaseDate: 'release_date',
    LastListenDate: 'last_listen_date',
    AddedDate: 'added_date',
    Plays: 'plays',
    Reposts: 'reposts',
    Saves: 'saves',
    MostListensByUser: 'most_listens_by_user'
} as const;
export type GetAIAttributedTracksByUserHandleSortMethodEnum = typeof GetAIAttributedTracksByUserHandleSortMethodEnum[keyof typeof GetAIAttributedTracksByUserHandleSortMethodEnum];
/**
 * @export
 */
export const GetAIAttributedTracksByUserHandleSortDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type GetAIAttributedTracksByUserHandleSortDirectionEnum = typeof GetAIAttributedTracksByUserHandleSortDirectionEnum[keyof typeof GetAIAttributedTracksByUserHandleSortDirectionEnum];
/**
 * @export
 */
export const GetAIAttributedTracksByUserHandleFilterTracksEnum = {
    All: 'all',
    Public: 'public',
    Unlisted: 'unlisted'
} as const;
export type GetAIAttributedTracksByUserHandleFilterTracksEnum = typeof GetAIAttributedTracksByUserHandleFilterTracksEnum[keyof typeof GetAIAttributedTracksByUserHandleFilterTracksEnum];
/**
 * @export
 */
export const GetTracksByUserSortEnum = {
    Date: 'date',
    Plays: 'plays'
} as const;
export type GetTracksByUserSortEnum = typeof GetTracksByUserSortEnum[keyof typeof GetTracksByUserSortEnum];
/**
 * @export
 */
export const GetTracksByUserSortMethodEnum = {
    Title: 'title',
    ArtistName: 'artist_name',
    ReleaseDate: 'release_date',
    LastListenDate: 'last_listen_date',
    AddedDate: 'added_date',
    Plays: 'plays',
    Reposts: 'reposts',
    Saves: 'saves',
    MostListensByUser: 'most_listens_by_user'
} as const;
export type GetTracksByUserSortMethodEnum = typeof GetTracksByUserSortMethodEnum[keyof typeof GetTracksByUserSortMethodEnum];
/**
 * @export
 */
export const GetTracksByUserSortDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type GetTracksByUserSortDirectionEnum = typeof GetTracksByUserSortDirectionEnum[keyof typeof GetTracksByUserSortDirectionEnum];
/**
 * @export
 */
export const GetTracksByUserFilterTracksEnum = {
    All: 'all',
    Public: 'public',
    Unlisted: 'unlisted'
} as const;
export type GetTracksByUserFilterTracksEnum = typeof GetTracksByUserFilterTracksEnum[keyof typeof GetTracksByUserFilterTracksEnum];
