import json
import logging
from datetime import datetime
from typing import List

import pytest
from web3 import Web3
from web3.datastructures import AttributeDict

from integration_tests.challenges.index_helpers import UpdateTask
from integration_tests.utils import populate_mock_db
from src.challenges.challenge_event_bus import ChallengeEventBus, setup_challenge_bus
from src.models.playlists.playlist import Playlist
from src.models.playlists.playlist_route import PlaylistRoute
from src.tasks.entity_manager.entity_manager import entity_manager_update
from src.tasks.entity_manager.utils import (
    CHARACTER_LIMIT_DESCRIPTION,
    PLAYLIST_ID_OFFSET,
)
from src.utils.db_session import get_db

logger = logging.getLogger(__name__)


@pytest.fixture()
def tx_receipts():
    test_metadata = {
        "QmCreatePlaylist1": {
            "playlist_contents": {"track_ids": []},
            "description": "",
            "playlist_image_sizes_multihash": "",
            "playlist_name": "playlist 1",
            "is_image_autogenerated": True,
            "is_private": True,
        },
        "QmCreatePlaylist2": {
            "playlist_contents": {"track_ids": []},
            "description": "test description",
            "playlist_image_sizes_multihash": "",
            "playlist_name": "playlist 2",
        },
        "QmCreatePlaylist4": {
            "playlist_contents": {"track_ids": []},
            "description": "",
            "playlist_image_sizes_multihash": "",
            "playlist_name": "playlist 4",
        },
        "QmUpdatePlaylist1": {
            "playlist_contents": {"track_ids": [{"time": 1660927554, "track": 1}]},
            "description": "",
            "playlist_image_sizes_multihash": "",
            "playlist_name": "playlist 1 updated",
            "is_private": False,
        },
        "QmUpdatePlaylist3": {
            "playlist_contents": {"track_ids": []},
            "description": "",
            "playlist_image_sizes_multihash": "",
            "playlist_name": "playlist 3 updated",
            "is_image_autogenerated": True,
        },
        "QmCreateAlbum4": {
            "playlist_contents": {"track_ids": [{"time": 1660927554, "track": 1}]},
            "description": "",
            "playlist_image_sizes_multihash": "",
            "playlist_name": "album",
            "is_album": True,
        },
        "QmCreateAlbum5": {  # scheduled release
            "playlist_contents": {"track_ids": [{"time": 1660927554, "track": 1}]},
            "description": "",
            "playlist_image_sizes_multihash": "",
            "playlist_name": "scheduled_album",
            "is_album": True,
            "is_private": False,  # Should be overwritten by is_scheduled_release
            "is_scheduled_release": True,
            "release_date": "2050-11-30T08:00:00.00Z",
        },
        "QmCreateAlbum6": {  # scheduled release to be published
            "playlist_contents": {"track_ids": [{"time": 1660927554, "track": 1}]},
            "description": "",
            "playlist_image_sizes_multihash": "",
            "playlist_name": "scheduled album to be published",
            "is_album": True,
            "is_private": True,
            "is_scheduled_release": True,
            "release_date": "Fri Jan 26 2100 00:00:00 GMT+0000",
        },
        "QmUpdateAlbum6": {
            "playlist_name": "scheduled album is now published",
            "is_private": False,
        },
    }

    create_playlist1_json = json.dumps(test_metadata["QmCreatePlaylist1"])
    create_playlist2_json = json.dumps(test_metadata["QmCreatePlaylist2"])
    create_playlist4_json = json.dumps(test_metadata["QmCreatePlaylist4"])
    update_playlist1_json = json.dumps(test_metadata["QmUpdatePlaylist1"])
    update_playlist3_json = json.dumps(test_metadata["QmUpdatePlaylist3"])
    create_album4_json = json.dumps(test_metadata["QmCreateAlbum4"])
    create_album5_json = json.dumps(test_metadata["QmCreateAlbum5"])
    create_album6_json = json.dumps(test_metadata["QmCreateAlbum6"])
    update_album6_json = json.dumps(test_metadata["QmUpdateAlbum6"])

    return {
        "CreatePlaylist1Tx": [
            {
                "args": AttributeDict(
                    {
                        "_entityId": PLAYLIST_ID_OFFSET,
                        "_entityType": "Playlist",
                        "_userId": 1,
                        "_action": "Create",
                        "_metadata": f'{{"cid": "QmCreatePlaylist1", "data": {create_playlist1_json}}}',
                        "_signer": "user1wallet",
                    }
                )
            },
        ],
        "UpdatePlaylist1Tx": [
            {
                "args": AttributeDict(
                    {
                        "_entityId": PLAYLIST_ID_OFFSET,
                        "_entityType": "Playlist",
                        "_userId": 1,
                        "_action": "Update",
                        "_metadata": f'{{"cid": "QmUpdatePlaylist1", "data": {update_playlist1_json}}}',
                        "_signer": "user1wallet",
                    }
                )
            },
        ],
        "DeletePlaylist1Tx": [
            {
                "args": AttributeDict(
                    {
                        "_entityId": PLAYLIST_ID_OFFSET,
                        "_entityType": "Playlist",
                        "_userId": 1,
                        "_action": "Delete",
                        "_metadata": "",
                        "_signer": "user1wallet",
                    }
                )
            },
        ],
        "CreatePlaylist2Tx": [
            {
                "args": AttributeDict(
                    {
                        "_entityId": PLAYLIST_ID_OFFSET + 1,
                        "_entityType": "Playlist",
                        "_userId": 1,
                        "_action": "Create",
                        "_metadata": f'{{"cid": "QmCreatePlaylist2", "data": {create_playlist2_json}}}',
                        "_signer": "user1wallet",
                    }
                )
            },
        ],
        "UpdatePlaylist3Tx": [
            {
                "args": AttributeDict(
                    {
                        "_entityId": PLAYLIST_ID_OFFSET + 2,
                        "_entityType": "Playlist",
                        "_userId": 1,
                        "_action": "Update",
                        "_metadata": f'{{"cid": "QmUpdatePlaylist3", "data": {update_playlist3_json}}}',
                        "_signer": "user1wallet",
                    }
                )
            },
        ],
        "CreateAlbum4Tx": [
            {
                "args": AttributeDict(
                    {
                        "_entityId": PLAYLIST_ID_OFFSET + 3,
                        "_entityType": "Playlist",
                        "_userId": 1,
                        "_action": "Create",
                        "_metadata": f'{{"cid": "QmCreateAlbum4", "data": {create_album4_json}}}',
                        "_signer": "user1wallet",
                    }
                )
            },
        ],
        "CreatePlaylist4Tx": [
            {
                "args": AttributeDict(
                    {
                        "_entityId": PLAYLIST_ID_OFFSET + 4,
                        "_entityType": "Playlist",
                        "_userId": 1,
                        "_action": "Create",
                        "_metadata": f'{{"cid": "QmCreatePlaylist4", "data": {create_playlist4_json}}}',
                        "_signer": "user1wallet",
                    }
                )
            },
        ],
        "CreatePlaylist5Tx": [
            {
                "args": AttributeDict(
                    {
                        "_entityId": PLAYLIST_ID_OFFSET + 5,
                        "_entityType": "Playlist",
                        "_userId": 1,
                        "_action": "Create",
                        "_metadata": f'{{"cid": "QmCreatePlaylist5", "data": {create_playlist4_json}}}',
                        "_signer": "0x3a388671bb4D6E1Ea08D79Ee191b40FB45A8F4C4",
                    }
                )
            },
        ],
        "CreateAlbum5Tx": [
            {
                "args": AttributeDict(
                    {
                        "_entityId": PLAYLIST_ID_OFFSET + 6,
                        "_entityType": "Playlist",
                        "_userId": 1,
                        "_action": "Create",
                        "_metadata": f'{{"cid": "QmCreateAlbum5", "data": {create_album5_json}}}',
                        "_signer": "user1wallet",
                    }
                )
            },
        ],
        "CreateAlbum6Tx": [
            {
                "args": AttributeDict(
                    {
                        "_entityId": PLAYLIST_ID_OFFSET + 7,
                        "_entityType": "Playlist",
                        "_userId": 1,
                        "_action": "Create",
                        "_metadata": f'{{"cid": "QmCreateAlbum6", "data": {create_album6_json}}}',
                        "_signer": "user1wallet",
                    }
                )
            },
        ],
        "UpdateAlbum6Tx": [
            {
                "args": AttributeDict(
                    {
                        "_entityId": PLAYLIST_ID_OFFSET + 7,
                        "_entityType": "Playlist",
                        "_userId": 1,
                        "_action": "Update",
                        "_metadata": f'{{"cid": "QmCreateAlbum6", "data": {update_album6_json}}}',
                        "_signer": "user1wallet",
                    }
                )
            },
        ],
    }


@pytest.fixture()
def tx_receipts_update_routes():
    test_metadata = {
        "QmCreatePlaylist1": {
            "playlist_contents": {"track_ids": []},
            "description": "",
            "playlist_image_sizes_multihash": "",
            "playlist_name": "my playlist~â€™",
        },
        "QmCreatePlaylist2": {
            "playlist_contents": {"track_ids": []},
            "description": "test description",
            "playlist_image_sizes_multihash": "",
            "playlist_name": "my playlist 2",
        },
        "QmCreatePlaylist3": {
            "playlist_contents": {"track_ids": []},
            "description": "test description",
            "playlist_image_sizes_multihash": "",
            "playlist_name": "my playlist!!",
        },
        "QmCreatePlaylist4": {
            "playlist_contents": {"track_ids": []},
            "description": "test description",
            "playlist_image_sizes_multihash": "",
            "playlist_name": "my ~playlist!!",
        },
        # only updating track, should not insert new slug row
        "QmUpdatePlaylist1": {
            "playlist_contents": {"track_ids": [{"time": 1660927554, "track": 1}]},
            "description": "",
            "playlist_image_sizes_multihash": "",
            "playlist_name": "my playlist",
        },
        "QmUpdatePlaylist12": {
            "playlist_contents": {"track_ids": []},
            "description": "",
            "playlist_image_sizes_multihash": "",
            "playlist_name": "my playlist 1 w/ new name!",
        },
        "QmCreatePlaylistDiffOwner": {
            "playlist_contents": {"track_ids": []},
            "description": "test desc",
            "playlist_image_sizes_multihash": "",
            "playlist_name": "my playlist",
        },
    }

    create_playlist1_json = json.dumps(test_metadata["QmCreatePlaylist1"])
    create_playlist2_json = json.dumps(test_metadata["QmCreatePlaylist2"])
    create_playlist3_json = json.dumps(test_metadata["QmCreatePlaylist3"])
    create_playlist4_json = json.dumps(test_metadata["QmCreatePlaylist4"])
    update_playlist1_json = json.dumps(test_metadata["QmUpdatePlaylist1"])
    update_playlist12_json = json.dumps(test_metadata["QmUpdatePlaylist12"])
    create_playlist_diff_owner_json = json.dumps(
        test_metadata["QmCreatePlaylistDiffOwner"]
    )

    return {
        "CreatePlaylist1Tx": [
            {
                "args": AttributeDict(
                    {
                        "_entityId": PLAYLIST_ID_OFFSET,
                        "_entityType": "Playlist",
                        "_userId": 1,
                        "_action": "Create",
                        "_metadata": f'{{"cid": "QmCreatePlaylist1", "data": {create_playlist1_json}}}',
                        "_signer": "user1wallet",
                    }
                )
            },
        ],
        "UpdatePlaylist1Tx": [
            {
                "args": AttributeDict(
                    {
                        "_entityId": PLAYLIST_ID_OFFSET,
                        "_entityType": "Playlist",
                        "_userId": 1,
                        "_action": "Update",
                        "_metadata": f'{{"cid": "QmUpdatePlaylist1", "data": {update_playlist1_json}}}',
                        "_signer": "user1wallet",
                    }
                )
            },
        ],
        "UpdatePlaylist12Tx": [
            {
                "args": AttributeDict(
                    {
                        "_entityId": PLAYLIST_ID_OFFSET,
                        "_entityType": "Playlist",
                        "_userId": 1,
                        "_action": "Update",
                        "_metadata": f'{{"cid": "QmUpdatePlaylist12", "data": {update_playlist12_json}}}',
                        "_signer": "user1wallet",
                    }
                )
            },
        ],
        "CreatePlaylist2Tx": [
            {
                "args": AttributeDict(
                    {
                        "_entityId": PLAYLIST_ID_OFFSET + 1,
                        "_entityType": "Playlist",
                        "_userId": 1,
                        "_action": "Create",
                        "_metadata": f'{{"cid": "QmCreatePlaylist2", "data": {create_playlist2_json}}}',
                        "_signer": "user1wallet",
                    }
                )
            },
        ],
        "CreatePlaylist3Tx": [
            {
                "args": AttributeDict(
                    {
                        "_entityId": PLAYLIST_ID_OFFSET + 4,
                        "_entityType": "Playlist",
                        "_userId": 1,
                        "_action": "Create",
                        "_metadata": f'{{"cid": "QmCreatePlaylist3", "data": {create_playlist3_json}}}',
                        "_signer": "user1wallet",
                    }
                )
            },
        ],
        "CreatePlaylist4Tx": [
            {
                "args": AttributeDict(
                    {
                        "_entityId": PLAYLIST_ID_OFFSET + 5,
                        "_entityType": "Playlist",
                        "_userId": 1,
                        "_action": "Create",
                        "_metadata": f'{{"cid": "QmCreatePlaylist4", "data": {create_playlist4_json}}}',
                        "_signer": "user1wallet",
                    }
                )
            },
        ],
        "CreatePlaylistDiffOwnerTx": [
            {
                "args": AttributeDict(
                    {
                        "_entityId": PLAYLIST_ID_OFFSET + 6,
                        "_entityType": "Playlist",
                        "_userId": 2,
                        "_action": "Create",
                        "_metadata": f'{{"cid": "QmCreateDiffOwner", "data": {create_playlist_diff_owner_json}}}',
                        "_signer": "user2wallet",
                    }
                )
            },
        ],
    }


def assert_playlist_route(route, route2):
    assert route.slug == route2.slug
    assert route.title_slug == route2.title_slug
    assert route.collision_id == route2.collision_id
    assert route.owner_id == route2.owner_id
    assert route.playlist_id == route2.playlist_id
    assert route.is_current == route2.is_current


def test_index_valid_playlists_updates_routes(app, mocker, tx_receipts_update_routes):
    "Tests valid batch of playlists create/update/delete actions"

    # setup db and mocked txs
    with app.app_context():
        db = get_db()
        web3 = Web3()
        challenge_event_bus: ChallengeEventBus = setup_challenge_bus()
        update_task = UpdateTask(web3, challenge_event_bus)

    entity_manager_txs = [
        AttributeDict({"transactionHash": update_task.web3.to_bytes(text=tx_receipt)})
        for tx_receipt in tx_receipts_update_routes
    ]

    def get_events_side_effect(_, tx_receipt):
        return tx_receipts_update_routes[tx_receipt["transactionHash"].decode("utf-8")]

    mocker.patch(
        "src.tasks.entity_manager.entity_manager.get_entity_manager_events_tx",
        side_effect=get_events_side_effect,
        autospec=True,
    )

    entities = {
        "users": [
            {"user_id": 1, "handle": "user-1", "wallet": "user1wallet"},
            {"user_id": 2, "handle": "user-2", "wallet": "user2wallet"},
        ],
        "playlists": [],
    }
    populate_mock_db(db, entities)

    with db.scoped_session() as session:
        # index transactions
        entity_manager_update(
            update_task,
            session,
            entity_manager_txs,
            block_number=0,
            block_timestamp=1585336422,
            block_hash=hex(0),
        )

        # validate db records
        playlist_routes = session.query(PlaylistRoute).all()
        assert len(playlist_routes) == 11

        expected_routes = [
            PlaylistRoute(
                slug="my-playlist",
                title_slug="my-playlist",
                collision_id=0,
                owner_id=1,
                playlist_id=400000,
                is_current=False,
            ),
            PlaylistRoute(
                slug="my-playlist-400000",
                title_slug="my-playlist-400000",
                collision_id=0,
                owner_id=1,
                playlist_id=400000,
                is_current=False,
            ),
            PlaylistRoute(
                slug="my-playlist-1-w-new-name",
                title_slug="my-playlist-1-w-new-name",
                collision_id=0,
                owner_id=1,
                playlist_id=400000,
                is_current=True,
            ),
            PlaylistRoute(
                slug="my-playlist-2",
                title_slug="my-playlist-2",
                collision_id=0,
                owner_id=1,
                playlist_id=400001,
                is_current=True,
            ),
            PlaylistRoute(
                slug="my-playlist-2-400001",
                title_slug="my-playlist-2-400001",
                collision_id=0,
                owner_id=1,
                playlist_id=400001,
                is_current=False,
            ),
            PlaylistRoute(
                slug="my-playlist-1",
                title_slug="my-playlist",
                collision_id=1,
                owner_id=1,
                playlist_id=400004,
                is_current=True,
            ),
            PlaylistRoute(
                slug="my-playlist-400004",
                title_slug="my-playlist-400004",
                collision_id=1,
                owner_id=1,
                playlist_id=400004,
                is_current=False,
            ),
            PlaylistRoute(
                slug="my-playlist-3",
                title_slug="my-playlist",
                collision_id=3,
                owner_id=1,
                playlist_id=400005,
                is_current=True,
            ),
            PlaylistRoute(
                slug="my-playlist-400005",
                title_slug="my-playlist-400005",
                collision_id=3,
                owner_id=1,
                playlist_id=400005,
                is_current=False,
            ),
            PlaylistRoute(
                slug="my-playlist",
                title_slug="my-playlist",
                collision_id=0,
                owner_id=2,
                playlist_id=400006,
                is_current=True,
            ),
            PlaylistRoute(
                slug="my-playlist-400006",
                title_slug="my-playlist-400006",
                collision_id=0,
                owner_id=2,
                playlist_id=400006,
                is_current=False,
            ),
        ]

        def sort_key(route):
            return (route.playlist_id, route.slug)

        sorted_routes = sorted(playlist_routes, key=sort_key)
        sorted_expected_routes = sorted(expected_routes, key=sort_key)
        for i in range(len(sorted_routes)):
            assert_playlist_route(sorted_routes[i], sorted_expected_routes[i])


def test_index_valid_playlists(app, mocker, tx_receipts):
    "Tests valid batch of playlists create/update/delete actions"

    # setup db and mocked txs
    with app.app_context():
        db = get_db()
        web3 = Web3()
        challenge_event_bus: ChallengeEventBus = setup_challenge_bus()
        update_task = UpdateTask(web3, challenge_event_bus)

    entity_manager_txs = [
        AttributeDict({"transactionHash": update_task.web3.to_bytes(text=tx_receipt)})
        for tx_receipt in tx_receipts
    ]

    def get_events_side_effect(_, tx_receipt):
        return tx_receipts[tx_receipt["transactionHash"].decode("utf-8")]

    mocker.patch(
        "src.tasks.entity_manager.entity_manager.get_entity_manager_events_tx",
        side_effect=get_events_side_effect,
        autospec=True,
    )

    entities = {
        "users": [
            {"user_id": 1, "handle": "user-1", "wallet": "user1wallet"},
        ],
        "playlists": [
            {
                "playlist_id": PLAYLIST_ID_OFFSET + 2,
                "playlist_owner_id": 1,
                "playlist_name": "playlist 3",
            }
        ],
        "developer_apps": [
            {
                "user_id": 2,
                "name": "My App",
                "address": "0x3a388671bb4D6E1Ea08D79Ee191b40FB45A8F4C4",
                "is_delete": False,
            },
            {
                "user_id": 2,
                "name": "My App 2",
                "address": "0x3a388671bb4D6E1Ea08D79Ee191b40FB45A8F4ZZ",
            },
        ],
        "grants": [
            {
                "user_id": 1,
                "grantee_address": "0x3a388671bb4D6E1Ea08D79Ee191b40FB45A8F4C4",
            },
            {
                "user_id": 1,
                "grantee_address": "0x3a388671bb4D6E1Ea08D79Ee191b40FB45A8F4ZZ",
                "is_revoked": True,
            },
        ],
    }
    populate_mock_db(db, entities)

    with db.scoped_session() as session:
        # index transactions
        entity_manager_update(
            update_task,
            session,
            entity_manager_txs,
            block_number=0,
            block_timestamp=1585336422,
            block_hash=hex(0),
        )

        # validate db records
        all_playlists: List[Playlist] = session.query(Playlist).all()
        assert len(all_playlists) == 8

        playlists_1: List[Playlist] = (
            session.query(Playlist)
            .filter(
                Playlist.is_current == True, Playlist.playlist_id == PLAYLIST_ID_OFFSET
            )
            .all()
        )
        assert len(playlists_1) == 1
        playlist_1 = playlists_1[0]
        assert datetime.timestamp(playlist_1.last_added_to) == 1585336422
        assert playlist_1.playlist_name == "playlist 1 updated"
        assert playlist_1.is_image_autogenerated == True
        assert playlist_1.is_delete == True
        assert playlist_1.is_current == True
        assert playlist_1.is_private == False

        playlists_2: List[Playlist] = (
            session.query(Playlist)
            .filter(
                Playlist.is_current == True,
                Playlist.playlist_id == PLAYLIST_ID_OFFSET + 1,
            )
            .all()
        )
        assert len(playlists_2) == 1
        playlist_2 = playlists_2[0]
        assert playlist_2.last_added_to == None
        assert playlist_2.playlist_name == "playlist 2"
        assert playlist_2.is_delete == False
        assert playlist_2.is_current == True

        playlists_3: List[Playlist] = (
            session.query(Playlist)
            .filter(
                Playlist.is_current == True,
                Playlist.playlist_id == PLAYLIST_ID_OFFSET + 2,
            )
            .all()
        )
        assert len(playlists_3) == 1
        playlist_3 = playlists_3[0]
        assert playlist_3.last_added_to == None
        assert playlist_3.playlist_name == "playlist 3 updated"
        assert playlist_3.is_image_autogenerated == True
        assert playlist_3.is_delete == False
        assert playlist_3.is_current == True

        playlists_4: List[Playlist] = (
            session.query(Playlist)
            .filter(
                Playlist.is_current == True,
                Playlist.playlist_id == PLAYLIST_ID_OFFSET + 4,
            )
            .all()
        )
        assert len(playlists_4) == 1
        playlist_4 = playlists_4[0]
        assert playlist_4.last_added_to == None
        assert playlist_4.playlist_name == "playlist 4"
        assert playlist_4.is_delete == False
        assert playlist_4.is_current == True

        playlists_5: List[Playlist] = (
            session.query(Playlist)
            .filter(
                Playlist.is_current == True,
                Playlist.playlist_id == PLAYLIST_ID_OFFSET + 5,
            )
            .all()
        )
        assert len(playlists_5) == 1

        albums: List[Playlist] = (
            session.query(Playlist)
            .filter(Playlist.is_current == True, Playlist.is_album == True)
            .all()
        )
        assert len(albums) == 3
        album = albums[0]
        assert datetime.timestamp(album.last_added_to) == 1585336422
        assert album.playlist_name == "album"
        assert album.is_delete == False
        assert album.is_current == True

        scheduled_album = albums[1]
        assert datetime.timestamp(scheduled_album.last_added_to) == 1585336422
        assert scheduled_album.playlist_name == "scheduled_album"
        assert scheduled_album.is_delete == False
        assert scheduled_album.is_current == True
        assert scheduled_album.is_private == True
        assert scheduled_album.is_scheduled_release == True

        published_album = albums[2]
        assert datetime.timestamp(published_album.last_added_to) == 1585336422
        assert published_album.playlist_name == "scheduled album is now published"
        assert published_album.is_private == False
        assert published_album.is_scheduled_release == False
        assert scheduled_album.release_date != datetime(2100, 1, 26, 0, 0)


def test_index_invalid_playlists(app, mocker):
    "Tests invalid batch of playlists create/update/delete actions"

    # setup db and mocked txs
    with app.app_context():
        db = get_db()
        web3 = Web3()
        challenge_event_bus: ChallengeEventBus = setup_challenge_bus()
        update_task = UpdateTask(web3, challenge_event_bus)

    test_metadata = {
        "UpdatePlaylistInvalidPrivate": {"is_private": True},
        "UpdatePlaylistInvalidAlbum": {"is_album": True},
        "UpdatePlaylistInvalidReleaseDate": {"release_date": "invalid"},
        "CreatePlaylistInvalidTracks": {
            "playlist_contents": {"track_ids": [{"track": 1}]}
        },
        "UpdatePlaylistInvalidPlaylistId": {"playlist_id": 1234},
    }
    private_metadata = json.dumps(test_metadata["UpdatePlaylistInvalidPrivate"])
    album_metadata = json.dumps(test_metadata["UpdatePlaylistInvalidAlbum"])
    invalid_release_date_metadata = json.dumps(
        test_metadata["UpdatePlaylistInvalidReleaseDate"]
    )
    invalid_playlist_id_metadata = json.dumps(
        test_metadata["UpdatePlaylistInvalidPlaylistId"]
    )
    playlist_metadata = json.dumps(test_metadata["CreatePlaylistInvalidTracks"])

    tx_receipts = {
        # invalid create
        "CreatePlaylistBelowOffset": [
            {
                "args": AttributeDict(
                    {
                        "_entityId": 1,
                        "_entityType": "Playlist",
                        "_userId": 1,
                        "_action": "Create",
                        "_metadata": "",
                        "_signer": "user1wallet",
                    }
                )
            },
        ],
        "CreatePlaylistUserDoesNotExist": [
            {
                "args": AttributeDict(
                    {
                        "_entityId": PLAYLIST_ID_OFFSET + 1,
                        "_entityType": "Playlist",
                        "_userId": 2,
                        "_action": "Create",
                        "_metadata": "",
                        "_signer": "user1wallet",
                    }
                )
            },
        ],
        "CreatePlaylistUserDoesNotMatchSigner": [
            {
                "args": AttributeDict(
                    {
                        "_entityId": PLAYLIST_ID_OFFSET + 2,
                        "_entityType": "Playlist",
                        "_userId": 1,
                        "_action": "Create",
                        "_metadata": "",
                        "_signer": "InvalidWallet",
                    }
                )
            },
        ],
        "CreatePlaylistRevokedAuthorizedApp": [
            {
                "args": AttributeDict(
                    {
                        "_entityId": PLAYLIST_ID_OFFSET + 2,
                        "_entityType": "Playlist",
                        "_userId": 1,
                        "_action": "Create",
                        "_metadata": "",
                        "_signer": "0x3a388671bb4D6E1Ea08D79Ee191b40FB45A8F4ZZ",
                    }
                )
            },
        ],
        "CreatePlaylistAlreadyExists": [
            {
                "args": AttributeDict(
                    {
                        "_entityId": PLAYLIST_ID_OFFSET,
                        "_entityType": "Playlist",
                        "_userId": 1,
                        "_action": "Create",
                        "_metadata": "",
                        "_signer": "user1wallet",
                    }
                )
            },
        ],
        "CreatePlaylistInvalidTracks": [
            {
                "args": AttributeDict(
                    {
                        "_entityId": PLAYLIST_ID_OFFSET,
                        "_entityType": "Playlist",
                        "_userId": 1,
                        "_action": "Create",
                        "_metadata": f'{{"cid": "CreatePlaylistInvalidTracks", "data": {playlist_metadata}}}',
                        "_signer": "user1wallet",
                    }
                )
            },
        ],
        # invalid updates
        "UpdatePlaylistInvalidSigner": [
            {
                "args": AttributeDict(
                    {
                        "_entityId": PLAYLIST_ID_OFFSET,
                        "_entityType": "Playlist",
                        "_userId": 1,
                        "_action": "Update",
                        "_metadata": "",
                        "_signer": "InvalidWallet",
                    }
                )
            },
        ],
        "UpdatePlaylistInvalidOwner": [
            {
                "args": AttributeDict(
                    {
                        "_entityId": PLAYLIST_ID_OFFSET,
                        "_entityType": "Playlist",
                        "_userId": 2,
                        "_action": "Update",
                        "_metadata": "",
                        "_signer": "User2Wallet",
                    }
                )
            },
        ],
        "UpdatePlaylistInvalidPrivate": [
            {
                "args": AttributeDict(
                    {
                        "_entityId": PLAYLIST_ID_OFFSET,
                        "_entityType": "Playlist",
                        "_userId": 1,
                        "_action": "Update",
                        "_metadata": f'{{"cid": "UpdatePlaylistInvalidPrivate", "data": {private_metadata}}}',
                        "_signer": "user1wallet",
                    }
                )
            },
        ],
        "UpdatePlaylistInvalidAlbum": [
            {
                "args": AttributeDict(
                    {
                        "_entityId": PLAYLIST_ID_OFFSET,
                        "_entityType": "Playlist",
                        "_userId": 1,
                        "_action": "Update",
                        "_metadata": f'{{"cid": "UpdatePlaylistInvalidAlbum", "data": {album_metadata}}}',
                        "_signer": "user1wallet",
                    }
                )
            },
        ],
        # invalid deletes
        "DeletePlaylistInvalidSigner": [
            {
                "args": AttributeDict(
                    {
                        "_entityId": PLAYLIST_ID_OFFSET,
                        "_entityType": "Playlist",
                        "_userId": 1,
                        "_action": "Delete",
                        "_metadata": "",
                        "_signer": "InvalidWallet",
                    }
                )
            },
        ],
        "DeletePlaylistDoesNotExist": [
            {
                "args": AttributeDict(
                    {
                        "_entityId": PLAYLIST_ID_OFFSET + 1,
                        "_entityType": "Playlist",
                        "_userId": 1,
                        "_action": "Update",
                        "_metadata": "",
                        "_signer": "user1wallet",
                    }
                )
            },
        ],
        "DeletePlaylistInvalidOwner": [
            {
                "args": AttributeDict(
                    {
                        "_entityId": PLAYLIST_ID_OFFSET + 1,
                        "_entityType": "Playlist",
                        "_userId": 2,
                        "_action": "Update",
                        "_metadata": "",
                        "_signer": "User2Wallet",
                    }
                )
            },
        ],
        "UpdatePlaylistInvalidReleaseDate": [
            {
                "args": AttributeDict(
                    {
                        "_entityId": PLAYLIST_ID_OFFSET,
                        "_entityType": "Playlist",
                        "_userId": 1,
                        "_action": "Update",
                        "_metadata": f'{{"cid": "UpdatePlaylistInvalidReleaseDate", "data": {invalid_release_date_metadata}}}',
                        "_signer": "user1wallet",
                    }
                )
            },
        ],
        "UpdatePlaylistInvalidPlaylistId": [
            {
                "args": AttributeDict(
                    {
                        "_entityId": PLAYLIST_ID_OFFSET,
                        "_entityType": "Playlist",
                        "_userId": 1,
                        "_action": "Update",
                        "_metadata": f'{{"cid": "UpdatePlaylistInvalidPlaylistId", "data": {invalid_playlist_id_metadata}}}',
                        "_signer": "user1wallet",
                    }
                )
            },
        ],
    }

    entity_manager_txs = [
        AttributeDict({"transactionHash": update_task.web3.to_bytes(text=tx_receipt)})
        for tx_receipt in tx_receipts
    ]

    def get_events_side_effect(_, tx_receipt):
        return tx_receipts[tx_receipt["transactionHash"].decode("utf-8")]

    mocker.patch(
        "src.tasks.entity_manager.entity_manager.get_entity_manager_events_tx",
        side_effect=get_events_side_effect,
        autospec=True,
    )

    entities = {
        "users": [
            {"user_id": 1, "handle": "user-1", "wallet": "user1wallet"},
            {"user_id": 2, "handle": "user-1", "wallet": "User2Wallet"},
        ],
        "playlists": [
            {"playlist_id": PLAYLIST_ID_OFFSET, "playlist_owner_id": 1},
            {
                "playlist_id": PLAYLIST_ID_OFFSET + 1,
                "playlist_owner_id": 1,
                "is_album": True,
            },
        ],
    }
    populate_mock_db(db, entities)
    with db.scoped_session() as session:
        # index transactions
        entity_manager_update(
            update_task,
            session,
            entity_manager_txs,
            block_number=0,
            block_timestamp=1585336422,
            block_hash=hex(0),
        )

        # validate db records
        all_playlists: List[Playlist] = session.query(Playlist).all()
        assert len(all_playlists) == 2

        current_playlist: Playlist = (
            session.query(Playlist)
            .filter(
                Playlist.is_current == True, Playlist.playlist_id == PLAYLIST_ID_OFFSET
            )
            .first()
        )
        assert current_playlist.is_current == True
        assert current_playlist.is_private == True
        assert current_playlist.is_album == False

        current_album: Playlist = (
            session.query(Playlist)
            .filter(
                Playlist.is_current == True,
                Playlist.playlist_id == PLAYLIST_ID_OFFSET + 1,
            )
            .first()
        )
        assert current_album.is_current == True
        assert current_album.is_album == True


def test_invalid_playlist_description(app, mocker):
    "Tests that playlists cant have a description that's too long"
    with app.app_context():
        db = get_db()
        web3 = Web3()
        update_task = UpdateTask(web3, None, None, None)

    metadata = {
        "PlaylistInvalidDescriptionMetadata": {
            "playlist_contents": {"track_ids": [{"time": 1660927554, "track": 1}]},
            "description": "xtralargeplz" * CHARACTER_LIMIT_DESCRIPTION,
            "playlist_image_sizes_multihash": "",
            "is_album": False,
        },
    }
    metadata = json.dumps(metadata["PlaylistInvalidDescriptionMetadata"])

    tx_receipts = {
        "PlaylistInvalidDescription": [
            {
                "args": AttributeDict(
                    {
                        "_entityId": PLAYLIST_ID_OFFSET + 4,
                        "_entityType": "Playlist",
                        "_userId": 1,
                        "_action": "Create",
                        "_metadata": f'{{"cid": "PlaylistInvalidDescriptionMetadata", "data": {metadata}}}',
                        "_signer": "user1wallet",
                    }
                )
            },
        ],
    }

    entity_manager_txs = [
        AttributeDict({"transactionHash": update_task.web3.to_bytes(text=tx_receipt)})
        for tx_receipt in tx_receipts
    ]

    def get_events_side_effect(_, tx_receipt):
        return tx_receipts[tx_receipt["transactionHash"].decode("utf-8")]

    mocker.patch(
        "src.tasks.entity_manager.entity_manager.get_entity_manager_events_tx",
        side_effect=get_events_side_effect,
        autospec=True,
    )

    entities = {
        "users": [
            {"user_id": 1, "handle": "user-1", "wallet": "user1wallet"},
        ],
        "playlist": [
            {"playlist_id": 1, "playlist_owner_id": 1, "is_album": True},
        ],
    }
    populate_mock_db(db, entities)

    with db.scoped_session() as session:
        total_changes, _ = entity_manager_update(
            update_task,
            session,
            entity_manager_txs,
            block_number=0,
            block_timestamp=1585336422,
            block_hash=hex(0),
        )

        assert total_changes == 0


def test_index_add_tracks_to_collections(app, mocker):
    "Tests adding tracks to albums and playlists. Tracks not owned by the album's owner should be ignored. Playlists allow all."

    # setup db and mocked txs
    with app.app_context():
        db = get_db()
        web3 = Web3()
        challenge_event_bus: ChallengeEventBus = setup_challenge_bus()
        update_task = UpdateTask(web3, challenge_event_bus)

    test_metadata = {
        "AlbumTracklistUpdate": {
            "playlist_contents": {
                "track_ids": [
                    {"time": 1660927554, "track": 1},
                    {"time": 1660927554, "track": 2},
                ]
            }
        },
        "PlaylistTracklistUpdate": {
            "playlist_contents": {
                "track_ids": [
                    {"time": 1660927554, "track": 1},
                    {"time": 1660927554, "track": 2},
                ]
            }
        },
    }

    album_tracklist_update_json = json.dumps(test_metadata["AlbumTracklistUpdate"])
    playlist_tracklist_update_json = json.dumps(
        test_metadata["PlaylistTracklistUpdate"]
    )

    tx_receipts = {
        "UpdateAlbumTracklistUpdate": [
            {
                "args": AttributeDict(
                    {
                        "_entityId": PLAYLIST_ID_OFFSET,
                        "_entityType": "Playlist",
                        "_userId": 1,
                        "_action": "Update",
                        "_metadata": f'{{"cid": "AlbumTracklistUpdate", "data": {album_tracklist_update_json}}}',
                        "_signer": "user1wallet",
                    }
                )
            }
        ],
        "UpdatePlaylistTracklistUpdate": [
            {
                "args": AttributeDict(
                    {
                        "_entityId": PLAYLIST_ID_OFFSET + 1,
                        "_entityType": "Playlist",
                        "_userId": 1,
                        "_action": "Update",
                        "_metadata": f'{{"cid": "PlaylistTracklistUpdate", "data": {playlist_tracklist_update_json}}}',
                        "_signer": "user1wallet",
                    }
                )
            }
        ],
    }

    entity_manager_txs = [
        AttributeDict({"transactionHash": update_task.web3.to_bytes(text=tx_receipt)})
        for tx_receipt in tx_receipts
    ]

    def get_events_side_effect(_, tx_receipt):
        return tx_receipts[tx_receipt["transactionHash"].decode("utf-8")]

    mocker.patch(
        "src.tasks.entity_manager.entity_manager.get_entity_manager_events_tx",
        side_effect=get_events_side_effect,
        autospec=True,
    )

    entities = {
        "users": [
            {"user_id": 1, "handle": "user-1", "wallet": "user1wallet"},
        ],
        "tracks": [
            {"track_id": 1, "owner_id": 1},
            {"track_id": 2, "owner_id": 2},
        ],
        "playlists": [
            {
                "playlist_id": PLAYLIST_ID_OFFSET,
                "playlist_owner_id": 1,
                "is_album": True,
            },
            {
                "playlist_id": PLAYLIST_ID_OFFSET + 1,
                "playlist_owner_id": 1,
                "is_album": False,
            },
        ],
    }
    populate_mock_db(db, entities)
    with db.scoped_session() as session:
        # index transactions
        entity_manager_update(
            update_task,
            session,
            entity_manager_txs,
            block_number=0,
            block_timestamp=1585336422,
            block_hash=hex(0),
        )

        # Validate album got only the single owned track
        all_playlists: List[Playlist] = session.query(Playlist).all()
        assert len(all_playlists) == 2

        album: Playlist = (
            session.query(Playlist)
            .filter(Playlist.playlist_id == PLAYLIST_ID_OFFSET)
            .first()
        )
        assert album.is_album == True
        assert len(album.playlist_contents["track_ids"]) == 1
        assert album.playlist_contents["track_ids"] <= [
            {"time": 1585336422, "track": 1, "metadata_time": 1660927554}
        ]

        # Validate playlist got both tracks
        playlist: Playlist = (
            session.query(Playlist)
            .filter(Playlist.playlist_id == PLAYLIST_ID_OFFSET + 1)
            .first()
        )
        assert playlist.is_album == False
        assert len(playlist.playlist_contents["track_ids"]) == 2
        assert playlist.playlist_contents["track_ids"] <= [
            {"metadata_time": 1660927554, "time": 1585336422, "track": 1},
            {"metadata_time": 1660927554, "time": 1585336422, "track": 2},
        ]


def test_access_conditions(app, mocker, tx_receipts):
    "Tests that playlists cannot have invalid access stream conditions"

    # setup db and mocked txs
    with app.app_context():
        db = get_db()
        web3 = Web3()
        challenge_event_bus: ChallengeEventBus = setup_challenge_bus()
        update_task = UpdateTask(web3, challenge_event_bus)

    test_metadata = {
        "CreatePublicAlbum": {
            "playlist_contents": {"track_ids": [{"time": 1660927554, "track": 1}]},
            "description": "",
            "playlist_image_sizes_multihash": "",
            "playlist_name": "album",
            "is_album": True,
        },
        "CreateAlbumAccessConditions": {
            "playlist_contents": {"track_ids": [{"time": 1660927554, "track": 1}]},
            "description": "",
            "playlist_image_sizes_multihash": "",
            "playlist_name": "album",
            "is_album": True,
            "is_stream_gated": True,
            "stream_conditions": {
                "usdc_purchase": {"price": 100, "splits": {"user-bank": 1000000}}
            },
        },
        "UpdatePlaylistMakePublic": {
            "playlist_contents": {"track_ids": [{"time": 1660927554, "track": 1}]},
            "description": "",
            "playlist_image_sizes_multihash": "",
            "playlist_name": "album",
            "is_stream_gated": False,
            "stream_conditions": None,
        },
        "InvalidCreatePlaylistAccessConditions": {
            "playlist_contents": {"track_ids": [{"time": 1660927554, "track": 1}]},
            "description": "",
            "playlist_image_sizes_multihash": "",
            "playlist_name": "album",
            "is_stream_gated": True,
            "stream_conditions": {
                "usdc_purchase": {"price": 100, "splits": {"user-bank": 1000000}}
            },
        },
        "InvalidCreateAlbumNoConditions": {
            "playlist_contents": {"track_ids": [{"time": 1660927554, "track": 1}]},
            "description": "",
            "playlist_image_sizes_multihash": "",
            "playlist_name": "album",
            "is_album": True,
            "is_stream_gated": True,
            "stream_conditions": None,
        },
    }

    create_album_access_conditions_json = json.dumps(
        test_metadata["CreateAlbumAccessConditions"]
    )
    update_album_make_public_json = json.dumps(
        test_metadata["UpdatePlaylistMakePublic"]
    )
    invalid_create_playlist_access_conditions_json = json.dumps(
        test_metadata["InvalidCreatePlaylistAccessConditions"]
    )
    invalid_create_album_no_conditions_json = json.dumps(
        test_metadata["InvalidCreateAlbumNoConditions"]
    )
    create_public_album_access_conditions_json = json.dumps(
        test_metadata["CreatePublicAlbum"]
    )

    tx_receipts = {
        "CreateAlbumAccessConditionsTx": [
            {
                "args": AttributeDict(
                    {
                        "_entityId": PLAYLIST_ID_OFFSET + 7,
                        "_entityType": "Playlist",
                        "_userId": 1,
                        "_action": "Create",
                        "_metadata": f'{{"cid": "CreateAlbumAccessConditions", "data": {create_album_access_conditions_json}}}',
                        "_signer": "user1wallet",
                    }
                )
            },
        ],
        "CreateAlbumAccessConditionsTx2": [
            {
                "args": AttributeDict(
                    {
                        "_entityId": PLAYLIST_ID_OFFSET + 8,
                        "_entityType": "Playlist",
                        "_userId": 1,
                        "_action": "Create",
                        "_metadata": f'{{"cid": "CreateAlbumAccessConditions2", "data": {create_album_access_conditions_json}}}',
                        "_signer": "user1wallet",
                    }
                )
            },
        ],
        "UpdateAlbumAccessConditionsMakePublicTx": [
            {
                "args": AttributeDict(
                    {
                        "_entityId": PLAYLIST_ID_OFFSET + 8,
                        "_entityType": "Playlist",
                        "_userId": 1,
                        "_action": "Update",
                        "_metadata": f'{{"cid": "UpdateAlbumAccessConditionsMakePublic", "data": {update_album_make_public_json}}}',
                        "_signer": "user1wallet",
                    }
                )
            },
        ],
        "InvalidCreatePlaylistAccessConditionsTx": [
            {
                "args": AttributeDict(
                    {
                        "_entityId": PLAYLIST_ID_OFFSET + 9,
                        "_entityType": "Playlist",
                        "_userId": 1,
                        "_action": "Update",
                        "_metadata": f'{{"cid": "InvalidCreatePlaylistAccessConditions", "data": {invalid_create_playlist_access_conditions_json}}}',
                        "_signer": "user1wallet",
                    }
                )
            }
        ],
        "InvalidCreateAlbumNoConditionsTx": [
            {
                "args": AttributeDict(
                    {
                        "_entityId": PLAYLIST_ID_OFFSET + 10,
                        "_entityType": "Playlist",
                        "_userId": 1,
                        "_action": "Update",
                        "_metadata": f'{{"cid": "InvalidCreateAlbumNoConditions", "data": {invalid_create_album_no_conditions_json}}}',
                        "_signer": "user1wallet",
                    }
                )
            }
        ],
        "CreatePublicAlbumTx": [
            {
                "args": AttributeDict(
                    {
                        "_entityId": PLAYLIST_ID_OFFSET + 11,
                        "_entityType": "Playlist",
                        "_userId": 1,
                        "_action": "Create",
                        "_metadata": f'{{"cid": "CreatePublicAlbum", "data": {create_public_album_access_conditions_json}}}',
                        "_signer": "user1wallet",
                    }
                )
            }
        ],
    }

    entity_manager_txs = [
        AttributeDict({"transactionHash": update_task.web3.to_bytes(text=tx_receipt)})
        for tx_receipt in tx_receipts
    ]

    def get_events_side_effect(_, tx_receipt):
        return tx_receipts[tx_receipt["transactionHash"].decode("utf-8")]

    mocker.patch(
        "src.tasks.entity_manager.entity_manager.get_entity_manager_events_tx",
        side_effect=get_events_side_effect,
        autospec=True,
    )

    entities = {
        "users": [
            {"user_id": 1, "handle": "user-1", "wallet": "user1wallet"},
        ],
        "tracks": [
            {"track_id": 1, "owner_id": 1},
        ],
    }
    populate_mock_db(db, entities)
    with db.scoped_session() as session:
        # index transactions
        entity_manager_update(
            update_task,
            session,
            entity_manager_txs,
            block_number=0,
            block_timestamp=1585336422,
            block_hash=hex(0),
        )

        # Validate usdc-gated album
        album: Playlist = (
            session.query(Playlist)
            .filter(Playlist.playlist_id == PLAYLIST_ID_OFFSET + 7)
            .first()
        )
        assert album.is_album == True
        assert album.is_stream_gated == True
        assert album.stream_conditions == {
            "usdc_purchase": {
                "price": 100,
                "splits": [{"user_id": 1, "percentage": 100}],
            }
        }

        # Validate previously usdc-gated album that is now public
        album: Playlist = (
            session.query(Playlist)
            .filter(Playlist.playlist_id == PLAYLIST_ID_OFFSET + 8)
            .first()
        )
        assert album.is_album == True
        assert album.is_stream_gated == False
        assert album.stream_conditions == None

        # Validate creating usdc-gated non-album playlist fails
        album: Playlist = (
            session.query(Playlist)
            .filter(Playlist.playlist_id == PLAYLIST_ID_OFFSET + 9)
            .first()
        )
        assert album == None

        # Validate creating usdc-gated album without stream_conditions fails
        album: Playlist = (
            session.query(Playlist)
            .filter(Playlist.playlist_id == PLAYLIST_ID_OFFSET + 10)
            .first()
        )
        assert album == None


def test_validate_playlist_tx_new_format(app, mocker):
    """Tests validation of playlist_contents in the new array format"""
    with app.app_context():
        db = get_db()
        web3 = Web3()
        challenge_event_bus: ChallengeEventBus = setup_challenge_bus()
        update_task = UpdateTask(web3, challenge_event_bus)

    test_metadata = {
        "ValidNewFormat": {
            "playlist_contents": [
                {"track": 1, "time": 1660927554},
                {"track_id": 2, "timestamp": 1660927555},
            ],
            "description": "test",
            "playlist_name": "playlist",
            "playlist_image_sizes_multihash": "",  # Required field
            "playlist_image_multihash": "",  # Required field
        },
        "InvalidNewFormat": {
            "playlist_contents": [{"invalid_field": 1}, {"track_id": 2}],
            "description": "test",
            "playlist_name": "playlist",
            "playlist_image_sizes_multihash": "",  # Required field
            "playlist_image_multihash": "",  # Required field
        },
    }

    valid_metadata = json.dumps(test_metadata["ValidNewFormat"])
    invalid_metadata = json.dumps(test_metadata["InvalidNewFormat"])

    tx_receipts = {
        "ValidNewFormatTx": [
            {
                "args": AttributeDict(
                    {
                        "_entityId": PLAYLIST_ID_OFFSET,
                        "_entityType": "Playlist",
                        "_userId": 1,
                        "_action": "Create",
                        "_metadata": f'{{"cid": "ValidNewFormat", "data": {valid_metadata}}}',
                        "_signer": "user1wallet",
                    }
                )
            }
        ],
        "InvalidNewFormatTx": [
            {
                "args": AttributeDict(
                    {
                        "_entityId": PLAYLIST_ID_OFFSET + 1,
                        "_entityType": "Playlist",
                        "_userId": 1,
                        "_action": "Create",
                        "_metadata": f'{{"cid": "InvalidNewFormat", "data": {invalid_metadata}}}',
                        "_signer": "user1wallet",
                    }
                )
            }
        ],
    }

    entity_manager_txs = [
        AttributeDict({"transactionHash": update_task.web3.to_bytes(text=tx_receipt)})
        for tx_receipt in tx_receipts
    ]

    def get_events_side_effect(_, tx_receipt):
        return tx_receipts[tx_receipt["transactionHash"].decode("utf-8")]

    mocker.patch(
        "src.tasks.entity_manager.entity_manager.get_entity_manager_events_tx",
        side_effect=get_events_side_effect,
        autospec=True,
    )

    entities = {
        "users": [{"user_id": 1, "handle": "user-1", "wallet": "user1wallet"}],
        "tracks": [{"track_id": 1, "owner_id": 1}, {"track_id": 2, "owner_id": 1}],
    }
    populate_mock_db(db, entities)

    with db.scoped_session() as session:
        # Valid format should succeed
        entity_manager_update(
            update_task,
            session,
            [entity_manager_txs[0]],
            block_number=0,
            block_timestamp=1585336422,
            block_hash=hex(0),
        )

        playlist = (
            session.query(Playlist)
            .filter(
                Playlist.playlist_id == PLAYLIST_ID_OFFSET, Playlist.is_current == True
            )
            .first()
        )
        assert playlist is not None
        assert len(playlist.playlist_contents["track_ids"]) == 2
        # Verify the track fields are correctly mapped
        for track in playlist.playlist_contents["track_ids"]:
            assert "track" in track
            assert "time" in track
            assert "metadata_time" in track

        # Invalid format should fail
        total_changes, _ = entity_manager_update(
            update_task,
            session,
            [entity_manager_txs[1]],
            block_number=0,
            block_timestamp=1585336422,
            block_hash=hex(0),
        )
        assert total_changes == 0


def test_playlist_creation_with_legacy_format(app, mocker):
    """Tests creating a playlist using the legacy nested track_ids format"""
    with app.app_context():
        db = get_db()
        web3 = Web3()
        challenge_event_bus: ChallengeEventBus = setup_challenge_bus()
        update_task = UpdateTask(web3, challenge_event_bus)

    test_metadata = {
        "playlist_contents": {
            "track_ids": [
                {"track": 1, "time": 1660927554},
                {"track": 2, "time": 1660927555},
            ]
        },
        "description": "Legacy format playlist",
        "playlist_name": "My Legacy Playlist",
        "playlist_image_sizes_multihash": "",
        "playlist_image_multihash": "",
    }

    tx_receipt = {
        "args": AttributeDict(
            {
                "_entityId": PLAYLIST_ID_OFFSET,
                "_entityType": "Playlist",
                "_userId": 1,
                "_action": "Create",
                "_metadata": f'{{"cid": "Legacy", "data": {json.dumps(test_metadata)}}}',
                "_signer": "user1wallet",
            }
        )
    }

    entity_manager_tx = AttributeDict(
        {"transactionHash": update_task.web3.to_bytes(text="LegacyTx")}
    )

    mocker.patch(
        "src.tasks.entity_manager.entity_manager.get_entity_manager_events_tx",
        return_value=[tx_receipt],
        autospec=True,
    )

    entities = {
        "users": [{"user_id": 1, "handle": "user-1", "wallet": "user1wallet"}],
        "tracks": [{"track_id": 1, "owner_id": 1}, {"track_id": 2, "owner_id": 1}],
    }
    populate_mock_db(db, entities)

    with db.scoped_session() as session:
        entity_manager_update(
            update_task,
            session,
            [entity_manager_tx],
            block_number=0,
            block_timestamp=1585336422,
            block_hash=hex(0),
        )

        playlist = (
            session.query(Playlist)
            .filter(
                Playlist.playlist_id == PLAYLIST_ID_OFFSET, Playlist.is_current == True
            )
            .first()
        )

        assert playlist is not None
        assert len(playlist.playlist_contents["track_ids"]) == 2
        assert playlist.playlist_contents["track_ids"][0]["track"] == 1
        assert playlist.playlist_contents["track_ids"][1]["track"] == 2


def test_playlist_creation_with_flattened_format(app, mocker):
    """Tests creating a playlist using the new flattened track array format"""
    with app.app_context():
        db = get_db()
        web3 = Web3()
        challenge_event_bus: ChallengeEventBus = setup_challenge_bus()
        update_task = UpdateTask(web3, challenge_event_bus)

    test_metadata = {
        "playlist_contents": [
            {"track": 1, "time": 1660927554},
            {
                "track_id": 2,
                "timestamp": 1660927555,
            },  # Tests both field naming conventions
        ],
        "description": "New format playlist",
        "playlist_name": "My New Playlist",
        "playlist_image_sizes_multihash": "",
        "playlist_image_multihash": "",
    }

    tx_receipt = {
        "args": AttributeDict(
            {
                "_entityId": PLAYLIST_ID_OFFSET,
                "_entityType": "Playlist",
                "_userId": 1,
                "_action": "Create",
                "_metadata": f'{{"cid": "New", "data": {json.dumps(test_metadata)}}}',
                "_signer": "user1wallet",
            }
        )
    }

    entity_manager_tx = AttributeDict(
        {"transactionHash": update_task.web3.to_bytes(text="NewTx")}
    )

    mocker.patch(
        "src.tasks.entity_manager.entity_manager.get_entity_manager_events_tx",
        return_value=[tx_receipt],
        autospec=True,
    )

    entities = {
        "users": [{"user_id": 1, "handle": "user-1", "wallet": "user1wallet"}],
        "tracks": [{"track_id": 1, "owner_id": 1}, {"track_id": 2, "owner_id": 1}],
    }
    populate_mock_db(db, entities)

    with db.scoped_session() as session:
        entity_manager_update(
            update_task,
            session,
            [entity_manager_tx],
            block_number=0,
            block_timestamp=1585336422,
            block_hash=hex(0),
        )

        playlist = (
            session.query(Playlist)
            .filter(
                Playlist.playlist_id == PLAYLIST_ID_OFFSET, Playlist.is_current == True
            )
            .first()
        )

        assert playlist is not None
        assert len(playlist.playlist_contents["track_ids"]) == 2
        assert playlist.playlist_contents["track_ids"][0]["track"] == 1
        assert playlist.playlist_contents["track_ids"][1]["track"] == 2


def test_playlist_update_preserves_track_order(app, mocker):
    """Tests that updating a playlist preserves track order and timing information"""
    with app.app_context():
        db = get_db()
        web3 = Web3()
        challenge_event_bus: ChallengeEventBus = setup_challenge_bus()
        update_task = UpdateTask(web3, challenge_event_bus)

    # First create a playlist
    initial_metadata = {
        "playlist_contents": [
            {"track": 1, "time": 1585336422},
            {"track": 2, "time": 1585336422},
        ],
        "description": "Initial playlist",
        "playlist_name": "My Playlist",
        "playlist_image_sizes_multihash": "",
        "playlist_image_multihash": "",
    }

    # Then update it with some changes
    update_metadata = {
        "playlist_contents": [
            {"track": 1, "time": 1585336422},  # Same track and time
            {"track": 2, "timestamp": 1585336425},  # Same track, new time
            {"track": 3, "time": 1585336425},  # New track
        ],
        "description": "Updated playlist",
        "playlist_name": "My Updated Playlist",
        "playlist_image_sizes_multihash": "",
        "playlist_image_multihash": "",
    }

    tx_receipts = [
        {
            "args": AttributeDict(
                {
                    "_entityId": PLAYLIST_ID_OFFSET,
                    "_entityType": "Playlist",
                    "_userId": 1,
                    "_action": "Create",
                    "_metadata": f'{{"cid": "Initial", "data": {json.dumps(initial_metadata)}}}',
                    "_signer": "user1wallet",
                }
            )
        },
        {
            "args": AttributeDict(
                {
                    "_entityId": PLAYLIST_ID_OFFSET,
                    "_entityType": "Playlist",
                    "_userId": 1,
                    "_action": "Update",
                    "_metadata": f'{{"cid": "Update", "data": {json.dumps(update_metadata)}}}',
                    "_signer": "user1wallet",
                }
            )
        },
    ]

    entity_manager_txs = [
        AttributeDict({"transactionHash": update_task.web3.to_bytes(text=f"Tx{i}")})
        for i in range(2)
    ]

    def get_events_side_effect(_, tx_receipt):
        idx = entity_manager_txs.index(tx_receipt)
        return [tx_receipts[idx]]

    mocker.patch(
        "src.tasks.entity_manager.entity_manager.get_entity_manager_events_tx",
        side_effect=get_events_side_effect,
        autospec=True,
    )

    entities = {
        "users": [{"user_id": 1, "handle": "user-1", "wallet": "user1wallet"}],
        "tracks": [{"track_id": i, "owner_id": 1} for i in range(1, 4)],
    }
    populate_mock_db(db, entities)

    with db.scoped_session() as session:
        # Create initial playlist
        entity_manager_update(
            update_task,
            session,
            [entity_manager_txs[0]],
            block_number=0,
            block_timestamp=1585336422,
            block_hash=hex(0),
        )

        # Update playlist
        entity_manager_update(
            update_task,
            session,
            [entity_manager_txs[1]],
            block_number=1,
            block_timestamp=1585336427,
            block_hash=hex(1),
        )

        playlist = (
            session.query(Playlist)
            .filter(
                Playlist.playlist_id == PLAYLIST_ID_OFFSET, Playlist.is_current == True
            )
            .first()
        )

        assert playlist is not None
        assert len(playlist.playlist_contents["track_ids"]) == 3

        # First track should keep original time
        assert playlist.playlist_contents["track_ids"][0]["track"] == 1
        assert playlist.playlist_contents["track_ids"][0]["time"] == 1585336422
        assert playlist.playlist_contents["track_ids"][0]["metadata_time"] == 1585336422

        # Second track should have updated index time, new metadata time
        assert playlist.playlist_contents["track_ids"][1]["track"] == 2
        assert playlist.playlist_contents["track_ids"][1]["time"] == 1585336427
        assert playlist.playlist_contents["track_ids"][1]["metadata_time"] == 1585336425

        # Third track added at same time as second track modified, should use same timestamps
        assert playlist.playlist_contents["track_ids"][2]["track"] == 3
        assert playlist.playlist_contents["track_ids"][2]["time"] == 1585336427
        assert playlist.playlist_contents["track_ids"][2]["metadata_time"] == 1585336425
