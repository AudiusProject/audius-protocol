import { isEqual } from 'lodash'

import { Collection } from 'models/Collection'
import { SquareSizes } from 'models/ImageSizes'
import { Track } from 'models/Track'
import { AudiusBackend } from 'services/audius-backend'

import { Nullable } from './typeUtils'

const filterTrack = (track1: Track) => (track2: Track) =>
  track1.track_id !== track2.track_id

type ArtworkActions = {
  added?: Track
  removed?: Track
  reordered?: Track[]
  updated?: Track[]
  regenerate?: boolean
}

type Context = {
  audiusBackend: AudiusBackend
  generateImage: (urls: string[]) => Promise<{ url: string; file: File }>
}

export const updatePlaylistArtwork = async (
  collection: Collection,
  tracks: Track[],
  actions: ArtworkActions,
  context: Context
) => {
  const { is_image_autogenerated, cover_art_sizes } = collection
  if (!is_image_autogenerated && cover_art_sizes && !actions.regenerate) {
    return collection
  }

  let tracksForImage: Nullable<Track[]> = null

  if (actions.added) {
    if (tracks.length === 0) {
      tracksForImage = [actions.added]
    } else if (tracks.length === 3) {
      tracksForImage = [...tracks, actions.added]
    }
  } else if (actions.removed) {
    const { removed } = actions
    const removedIndex = tracks.findIndex(
      (track) => track.track_id === removed.track_id
    )
    if (removedIndex === -1) {
      // continue
    } else if (tracks.length > 4 && removedIndex < 4) {
      tracksForImage = tracks.filter(filterTrack(removed)).slice(0, 4)
    } else if (tracks.length === 4) {
      tracksForImage = tracks.filter(filterTrack(removed)).slice(0, 1)
    } else if (tracks.length < 4) {
      if (tracks.length === 1) {
        tracksForImage = []
      } else if (removedIndex === 0) {
        tracksForImage = tracks.slice(1, 2)
      }
    }
  } else if (actions.reordered) {
    if (
      tracks.length >= 4 &&
      !isEqual(actions.reordered.slice(0, 4), tracks.slice(0, 4))
    ) {
      tracksForImage = actions.reordered.slice(0, 4)
    } else if (tracks.length < 4 && !isEqual(actions.reordered[0], tracks[0])) {
      tracksForImage = [actions.reordered[0]]
    }
  } else if (actions.updated) {
    if (actions.updated.length < 4 && tracks.length < 4) {
      if (!isEqual(actions.updated[0], tracks[0])) {
        tracksForImage = [actions.updated[0]]
      }
    } else if (actions.updated.length < 4 && tracks.length >= 4) {
      tracksForImage = [actions.updated[0]]
    } else if (!isEqual(actions.updated.slice(0, 4), tracks.slice(0, 4))) {
      tracksForImage = actions.updated.slice(0, 4)
    }
  } else if (actions.regenerate) {
    if (tracks.length < 4) {
      tracksForImage = tracks.slice(0, 1)
    } else {
      tracksForImage = tracks.slice(0, 4)
    }
  }

  if (tracksForImage) {
    if (tracksForImage.length === 0) {
      // @ts-expect-error
      collection.cover_art_sizes = undefined
      collection._cover_art_sizes = {}
    } else {
      const sizes =
        tracksForImage.length === 1
          ? SquareSizes.SIZE_1000_BY_1000
          : SquareSizes.SIZE_480_BY_480
      const trackUrls = await Promise.all(
        tracksForImage.map(async (track) => {
          const { cover_art_cids, cover_art_sizes, cover_art } = track
          return await context.audiusBackend.getImageUrl(
            cover_art_sizes ?? cover_art,
            sizes,
            cover_art_cids
          )
        })
      )

      const artwork = await context.generateImage(trackUrls)
      collection.artwork = artwork
      collection.is_image_autogenerated = true
    }
  }

  return collection
}
